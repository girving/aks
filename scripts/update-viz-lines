#!/usr/bin/env python3
"""Update line numbers in docs/index.html PROOF_DATA from source files.

Reads the PROOF_DATA JSON block, greps each node's source file for its
definition, updates the line number, and writes back the HTML.

Usage:
  scripts/update-viz-lines          # Update in place
  scripts/update-viz-lines --check  # Exit 1 if any line numbers are stale
"""

import json
import os
import re
import sys

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
INDEX_HTML = os.path.join(PROJECT_ROOT, "docs", "index.html")

# Patterns that introduce a named declaration in Lean
DECL_KEYWORDS = [
    "theorem", "lemma", "def", "noncomputable def", "private def",
    "private theorem", "private lemma", "structure", "axiom",
    "noncomputable private def", "private noncomputable def",
    "class", "instance", "abbrev", "opaque",
]


def find_line(filepath: str, name: str) -> int | None:
    """Find the line number where `name` is declared in `filepath`."""
    full = os.path.join(PROJECT_ROOT, filepath)
    if not os.path.exists(full):
        return None

    # Strip module prefix: "RegularGraph.square" -> "square" for matching,
    # but also try the full name
    short = name.split(".")[-1] if "." in name else name
    candidates = {name, short}

    with open(full) as f:
        lines = f.readlines()

    for i, line in enumerate(lines, 1):
        stripped = line.strip()
        for kw in DECL_KEYWORDS:
            for cand in candidates:
                # Match: "keyword name" possibly followed by space, {, (, :, etc.
                # The name may have a dot-qualified prefix (e.g., "RegularGraph.walkCLM")
                pattern = rf"^{re.escape(kw)}\s+(?:\w+\.)*{re.escape(cand)}[\s{{(:\[\.]"
                if re.match(pattern, stripped):
                    return i
                # Also match exact "keyword name" at end of line (no trailing char)
                pattern2 = rf"^{re.escape(kw)}\s+(?:\w+\.)*{re.escape(cand)}$"
                if re.match(pattern2, stripped):
                    return i

    return None


def extract_proof_data(html: str) -> tuple[str, int, int]:
    """Extract the PROOF_DATA JSON string and its position in the HTML."""
    # Find "const PROOF_DATA = {" and the matching "};"
    start_match = re.search(r"const PROOF_DATA = \{", html)
    if not start_match:
        raise ValueError("Could not find PROOF_DATA in HTML")

    # Find the closing "};" by brace counting from the opening "{"
    brace_start = start_match.start() + len("const PROOF_DATA = ")
    depth = 0
    i = brace_start
    while i < len(html):
        if html[i] == "{":
            depth += 1
        elif html[i] == "}":
            depth -= 1
            if depth == 0:
                brace_end = i + 1
                break
        i += 1
    else:
        raise ValueError("Could not find closing brace for PROOF_DATA")

    return html[brace_start:brace_end], brace_start, brace_end


def update_line_in_node(node_text: str, old_line: int, new_line: int) -> str:
    """Replace 'line: OLD' with 'line: NEW' in a node's JSON-like text."""
    return re.sub(
        rf"\bline:\s*{old_line}\b",
        f"line: {new_line}",
        node_text,
        count=1,
    )


def main():
    check_mode = "--check" in sys.argv

    with open(INDEX_HTML) as f:
        html = f.read()

    # Extract all node entries with regex (JS object literals, not strict JSON)
    # Find each "{ id: "...", file: "...", line: N, ... }" block
    node_pattern = re.compile(
        r'\{\s*id:\s*"([^"]+)"\s*,\s*file:\s*"([^"]+)"\s*,\s*line:\s*(\d+)'
    )

    updates = []  # (id, file, old_line, new_line)
    stale = []

    for m in node_pattern.finditer(html):
        node_id = m.group(1)
        filepath = m.group(2)
        old_line = int(m.group(3))

        new_line = find_line(filepath, node_id)
        if new_line is None:
            print(f"  WARN  {node_id} ({filepath}): not found in source")
            continue

        if new_line != old_line:
            updates.append((node_id, filepath, old_line, new_line, m.start(), m.end()))
            stale.append(node_id)

    if not updates:
        print("All line numbers are up to date.")
        return 0

    # Report
    for node_id, filepath, old_line, new_line, _, _ in updates:
        print(f"  {'STALE' if check_mode else 'UPDATE'}  {node_id} ({filepath}): {old_line} â†’ {new_line}")

    if check_mode:
        print(f"\n{len(stale)} stale line number(s). Run scripts/update-viz-lines to fix.")
        return 1

    # Apply updates (reverse order to preserve positions)
    result = html
    for node_id, filepath, old_line, new_line, start, end in reversed(updates):
        # Replace just the line number in this match region
        old_text = result[start:end]
        new_text = update_line_in_node(old_text, old_line, new_line)
        result = result[:start] + new_text + result[end:]

    with open(INDEX_HTML, "w") as f:
        f.write(result)

    print(f"\nUpdated {len(updates)} line number(s) in docs/index.html.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
