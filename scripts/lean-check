#!/usr/bin/env python3
"""Check a Lean file via the persistent lean-daemon.

The daemon auto-starts on first use; no need to run --start explicitly.

Usage:
  scripts/lean-check AKS/RegularGraph.lean
  scripts/lean-check --all       # Check all project .lean files
  scripts/lean-check --start     # Start the daemon (optional, happens automatically)
  scripts/lean-check --stop      # Stop the daemon
  scripts/lean-check --ping      # Check if daemon is running

Exit codes:
  0 = no errors (warnings are OK)
  1 = errors found
  2 = daemon not running / failed to start
"""

import json
import os
import socket
import subprocess
import sys
import time

SOCKET_PATH = "/tmp/lean-daemon.sock"
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DAEMON_SCRIPT = os.path.join(PROJECT_ROOT, "scripts", "lean-daemon.py")
PID_FILE = "/tmp/lean-daemon.pid"


def send_command(cmd: dict, timeout: float = 180) -> dict:
    """Send a command to the daemon and get the response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect(SOCKET_PATH)
        sock.sendall((json.dumps(cmd) + "\n").encode("utf-8"))
        data = b""
        while True:
            chunk = sock.recv(65536)
            if not chunk:
                break
            data += chunk
        return json.loads(data.decode("utf-8"))
    finally:
        sock.close()


def daemon_running() -> bool:
    """Check if the daemon is running."""
    try:
        resp = send_command({"command": "ping"}, timeout=5)
        return resp.get("status") == "ok"
    except (ConnectionRefusedError, FileNotFoundError, OSError):
        return False


def start_daemon():
    """Start the daemon in the background."""
    if daemon_running():
        print("Daemon already running.")
        return True

    print("Starting lean-daemon...")
    proc = subprocess.Popen(
        [sys.executable, DAEMON_SCRIPT],
        stdout=open("/tmp/lean-daemon.log", "w"),
        stderr=subprocess.STDOUT,
        cwd=PROJECT_ROOT,
    )
    with open(PID_FILE, "w") as f:
        f.write(str(proc.pid))

    # Wait for daemon to be ready
    for i in range(60):
        time.sleep(1)
        if daemon_running():
            print(f"Daemon started (pid {proc.pid}).")
            return True
        # Check if process died
        if proc.poll() is not None:
            print("Daemon process exited unexpectedly. Log:")
            with open("/tmp/lean-daemon.log") as f:
                print(f.read())
            return False
        if i % 5 == 4:
            print(f"  Waiting for daemon... ({i+1}s)")

    print("Daemon failed to start within 60s.")
    return False


def stop_daemon():
    """Stop the daemon."""
    if not daemon_running():
        print("Daemon not running.")
        # Clean up stale files
        for f in [SOCKET_PATH, PID_FILE]:
            if os.path.exists(f):
                os.unlink(f)
        return

    try:
        send_command({"command": "shutdown"}, timeout=5)
        print("Daemon stopped.")
    except Exception:
        # Force kill
        if os.path.exists(PID_FILE):
            with open(PID_FILE) as f:
                pid = int(f.read().strip())
            try:
                os.kill(pid, 9)
                print(f"Daemon killed (pid {pid}).")
            except ProcessLookupError:
                pass
            os.unlink(PID_FILE)

    if os.path.exists(SOCKET_PATH):
        os.unlink(SOCKET_PATH)


def format_diagnostic(d: dict) -> str:
    """Format a single diagnostic for display."""
    severity = d.get("severity", 1)
    sev_str = {1: "error", 2: "warning", 3: "info", 4: "hint"}.get(severity, "?")
    rng = d.get("range", {})
    start = rng.get("start", {})
    line = start.get("line", 0) + 1
    col = start.get("character", 0)
    msg = d.get("message", "").split("\n")[0]  # First line only
    return f"  {sev_str} [{line}:{col}]: {msg}"


def check_file(filepath: str):
    """Check a file and print results. Auto-starts daemon if needed."""
    if not daemon_running():
        if not start_daemon():
            sys.exit(2)

    t0 = time.time()
    result = send_command({"command": "check", "file": filepath})
    wall_time = time.time() - t0

    if "error" in result:
        print(f"Error: {result['error']}")
        sys.exit(2)

    diagnostics = result.get("diagnostics", [])
    server_time = result.get("time_seconds", "?")
    errors = [d for d in diagnostics if d.get("severity", 0) == 1]
    warnings = [d for d in diagnostics if d.get("severity", 0) == 2]

    print(f"Checked {filepath} in {server_time}s (wall: {wall_time:.1f}s)")

    if errors:
        print(f"\n{len(errors)} error(s):")
        for d in errors:
            print(format_diagnostic(d))

    if warnings:
        print(f"\n{len(warnings)} warning(s):")
        for d in warnings:
            print(format_diagnostic(d))

    if not errors and not warnings:
        print("No errors or warnings.")

    sys.exit(1 if errors else 0)


def find_project_files():
    """Find all project .lean files (excluding lake dependencies)."""
    import glob
    files = []
    for pattern in ["AKS.lean", "AKS/**/*.lean"]:
        files.extend(glob.glob(pattern, root_dir=PROJECT_ROOT, recursive=True))
    return sorted(set(files))


def check_all():
    """Check all project .lean files. Auto-starts daemon if needed."""
    if not daemon_running():
        if not start_daemon():
            sys.exit(2)

    files = find_project_files()
    if not files:
        print("No .lean files found.")
        sys.exit(2)

    print(f"Checking {len(files)} file(s)...\n")
    total_errors = 0
    total_warnings = 0
    failed_files = []

    for filepath in files:
        t0 = time.time()
        result = send_command({"command": "check", "file": filepath})
        wall_time = time.time() - t0

        if "error" in result:
            print(f"  FAIL  {filepath}: {result['error']}")
            failed_files.append(filepath)
            total_errors += 1
            continue

        diagnostics = result.get("diagnostics", [])
        server_time = result.get("time_seconds", "?")
        errors = [d for d in diagnostics if d.get("severity", 0) == 1]
        warnings = [d for d in diagnostics if d.get("severity", 0) == 2]

        status = "FAIL" if errors else "  ok"
        parts = [f"{status}  {filepath} ({server_time}s)"]
        if errors:
            parts.append(f" — {len(errors)} error(s)")
            failed_files.append(filepath)
        if warnings:
            parts.append(f" — {len(warnings)} warning(s)")
        print("".join(parts))

        if errors:
            for d in errors:
                print(f"        {format_diagnostic(d)}")

        total_errors += len(errors)
        total_warnings += len(warnings)

    print(f"\n{'='*50}")
    print(f"{len(files)} files checked, {total_errors} error(s), {total_warnings} warning(s)")
    if failed_files:
        print(f"Failed: {', '.join(failed_files)}")
    sys.exit(1 if failed_files else 0)


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    arg = sys.argv[1]

    if arg == "--start":
        sys.exit(0 if start_daemon() else 1)
    elif arg == "--stop":
        stop_daemon()
    elif arg == "--ping":
        if daemon_running():
            print("Daemon is running.")
        else:
            print("Daemon is NOT running.")
            sys.exit(2)
    elif arg == "--all":
        check_all()
    elif arg.endswith(".lean"):
        check_file(arg)
    else:
        print(f"Unknown argument: {arg}")
        print(__doc__)
        sys.exit(1)


if __name__ == "__main__":
    main()
