#!/usr/bin/env python3
"""Check a Lean file via the persistent lean-daemon.

The daemon auto-starts on first use; no need to run --start explicitly.

Usage:
  scripts/lean-check AKS/RegularGraph.lean
  scripts/lean-check --all       # Check all project .lean files
  scripts/lean-check --start     # Start the daemon (optional, happens automatically)
  scripts/lean-check --stop      # Stop the daemon
  scripts/lean-check --ping      # Check if daemon is running

Exit codes:
  0 = no errors (warnings are OK)
  1 = errors found
  2 = daemon not running / failed to start
"""

import json
import os
import socket
import subprocess
import sys
import time

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DAEMON_SCRIPT = os.path.join(PROJECT_ROOT, "scripts", "lean-daemon.py")
# Derive unique paths from project root so multiple daemons can coexist
import hashlib
_project_hash = hashlib.md5(PROJECT_ROOT.encode()).hexdigest()[:8]
SOCKET_PATH = f"/tmp/lean-daemon-{_project_hash}.sock"
PID_FILE = f"/tmp/lean-daemon-{_project_hash}.pid"


def send_command(cmd: dict, timeout: float = 180) -> dict:
    """Send a command to the daemon and get the response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect(SOCKET_PATH)
        sock.sendall((json.dumps(cmd) + "\n").encode("utf-8"))
        data = b""
        while True:
            chunk = sock.recv(65536)
            if not chunk:
                break
            data += chunk
        return json.loads(data.decode("utf-8"))
    finally:
        sock.close()


def daemon_running() -> bool:
    """Check if the daemon is running."""
    try:
        resp = send_command({"command": "ping"}, timeout=5)
        return resp.get("status") == "ok"
    except (ConnectionRefusedError, FileNotFoundError, OSError):
        return False


def ensure_mathlib_cache():
    """Download Mathlib cache if not present."""
    import glob

    # Check if Mathlib .olean files exist
    mathlib_olean = os.path.join(PROJECT_ROOT, ".lake/packages/mathlib/.lake/build/lib/lean/Mathlib.olean")
    if os.path.exists(mathlib_olean):
        return  # Cache already present

    print("Mathlib cache not found. Downloading...")
    print("(This is a one-time operation, ~30s)")
    result = subprocess.run(
        ["lake", "exe", "cache", "get"],
        cwd=PROJECT_ROOT,
        capture_output=False,
        text=True
    )
    if result.returncode != 0:
        print("Warning: Failed to download Mathlib cache. Continuing anyway...")
    else:
        print("Mathlib cache downloaded successfully.")


def start_daemon():
    """Start the daemon in the background."""
    if daemon_running():
        print("Daemon already running.")
        return True

    # Ensure Mathlib cache is downloaded before starting daemon
    ensure_mathlib_cache()

    print("Starting lean-daemon...")
    proc = subprocess.Popen(
        [sys.executable, DAEMON_SCRIPT],
        stdout=open(f"/tmp/lean-daemon-{_project_hash}.log", "w"),
        stderr=subprocess.STDOUT,
        cwd=PROJECT_ROOT,
    )
    with open(PID_FILE, "w") as f:
        f.write(str(proc.pid))

    # Wait for daemon to be ready
    for i in range(60):
        time.sleep(1)
        if daemon_running():
            print(f"Daemon started (pid {proc.pid}).")
            return True
        # Check if process died
        if proc.poll() is not None:
            print("Daemon process exited unexpectedly. Log:")
            with open(f"/tmp/lean-daemon-{_project_hash}.log") as f:
                print(f.read())
            return False
        if i % 5 == 4:
            print(f"  Waiting for daemon... ({i+1}s)")

    print("Daemon failed to start within 60s.")
    return False


def stop_daemon():
    """Stop the daemon."""
    if not daemon_running():
        print("Daemon not running.")
        # Clean up stale files
        for f in [SOCKET_PATH, PID_FILE]:
            if os.path.exists(f):
                os.unlink(f)
        return

    try:
        send_command({"command": "shutdown"}, timeout=5)
        print("Daemon stopped.")
    except Exception:
        # Force kill
        if os.path.exists(PID_FILE):
            with open(PID_FILE) as f:
                pid = int(f.read().strip())
            try:
                os.kill(pid, 9)
                print(f"Daemon killed (pid {pid}).")
            except ProcessLookupError:
                pass
            os.unlink(PID_FILE)

    if os.path.exists(SOCKET_PATH):
        os.unlink(SOCKET_PATH)


def format_diagnostic(d: dict) -> str:
    """Format a single diagnostic for display."""
    severity = d.get("severity", 1)
    sev_str = {1: "error", 2: "warning", 3: "info", 4: "hint"}.get(severity, "?")
    rng = d.get("range", {})
    start = rng.get("start", {})
    line = start.get("line", 0) + 1
    col = start.get("character", 0)
    msg = d.get("message", "")

    # Format multi-line messages with proper indentation
    lines = msg.split("\n")
    if len(lines) == 1:
        return f"  {sev_str} [{line}:{col}]: {msg}"
    else:
        # First line with label, subsequent lines indented
        result = [f"  {sev_str} [{line}:{col}]: {lines[0]}"]
        for subsequent_line in lines[1:]:
            if subsequent_line:  # Skip empty lines
                result.append(f"    {subsequent_line}")
        return "\n".join(result)


def check_file(filepath: str):
    """Check a single file. Returns (output_lines, error_count)."""
    lines = []
    t0 = time.time()
    result = send_command({"command": "check", "file": filepath})
    wall_time = time.time() - t0

    if "error" in result:
        lines.append(f"Error: {result['error']}")
        return (lines, 1)

    diagnostics = result.get("diagnostics", [])
    server_time = result.get("time_seconds", "?")
    errors = [d for d in diagnostics if d.get("severity", 0) == 1]
    warnings = [d for d in diagnostics if d.get("severity", 0) == 2]

    lines.append(f"Checked {filepath} in {server_time}s (wall: {wall_time:.1f}s)")

    if errors:
        lines.append(f"\n{len(errors)} error(s):")
        for d in errors:
            lines.append(format_diagnostic(d))

    if warnings:
        lines.append(f"\n{len(warnings)} warning(s):")
        for d in warnings:
            lines.append(format_diagnostic(d))

    if not errors and not warnings:
        lines.append("No errors or warnings.")

    return (lines, len(errors))


def check_files(filepaths: list):
    """Check one or more files in parallel. Auto-starts daemon if needed."""
    if not daemon_running():
        if not start_daemon():
            sys.exit(2)

    if len(filepaths) == 1:
        lines, errs = check_file(filepaths[0])
        print("\n".join(lines))
        sys.exit(1 if errs else 0)

    from concurrent.futures import ThreadPoolExecutor

    with ThreadPoolExecutor(max_workers=len(filepaths)) as pool:
        results = list(pool.map(check_file, filepaths))

    total_errors = 0
    for lines, errs in results:
        print("\n".join(lines))
        print()
        total_errors += errs

    sys.exit(1 if total_errors else 0)


def find_project_files():
    """Find all project .lean files (excluding lake dependencies)."""
    import glob
    files = []
    for pattern in ["AKS.lean", "AKS/**/*.lean"]:
        files.extend(glob.glob(pattern, root_dir=PROJECT_ROOT, recursive=True))
    return sorted(set(files))


def check_all():
    """Check all project .lean files. Auto-starts daemon if needed."""
    if not daemon_running():
        if not start_daemon():
            sys.exit(2)

    files = find_project_files()
    if not files:
        print("No .lean files found.")
        sys.exit(2)

    print(f"Checking {len(files)} file(s)...\n")
    total_errors = 0
    total_warnings = 0
    failed_files = []

    for filepath in files:
        t0 = time.time()
        result = send_command({"command": "check", "file": filepath})
        wall_time = time.time() - t0

        if "error" in result:
            print(f"  FAIL  {filepath}: {result['error']}")
            failed_files.append(filepath)
            total_errors += 1
            continue

        diagnostics = result.get("diagnostics", [])
        server_time = result.get("time_seconds", "?")
        errors = [d for d in diagnostics if d.get("severity", 0) == 1]
        warnings = [d for d in diagnostics if d.get("severity", 0) == 2]

        status = "FAIL" if errors else "  ok"
        parts = [f"{status}  {filepath} ({server_time}s)"]
        if errors:
            parts.append(f" — {len(errors)} error(s)")
            failed_files.append(filepath)
        if warnings:
            parts.append(f" — {len(warnings)} warning(s)")
        print("".join(parts))

        if errors:
            for d in errors:
                print(f"        {format_diagnostic(d)}")

        total_errors += len(errors)
        total_warnings += len(warnings)

    print(f"\n{'='*50}")
    print(f"{len(files)} files checked, {total_errors} error(s), {total_warnings} warning(s)")
    if failed_files:
        print(f"Failed: {', '.join(failed_files)}")
    sys.exit(1 if failed_files else 0)


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    arg = sys.argv[1]

    if arg == "--start":
        sys.exit(0 if start_daemon() else 1)
    elif arg == "--stop":
        stop_daemon()
    elif arg == "--ping":
        if daemon_running():
            print("Daemon is running.")
        else:
            print("Daemon is NOT running.")
            sys.exit(2)
    elif arg == "--all":
        check_all()
    else:
        lean_files = [a for a in sys.argv[1:] if a.endswith(".lean")]
        if lean_files:
            check_files(lean_files)
        else:
            print(f"Unknown argument: {arg}")
            print(__doc__)
            sys.exit(1)


if __name__ == "__main__":
    main()
