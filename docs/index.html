<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AKS Sorting Network — Proof Dependency Graph</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0d1117; color: #c9d1d9; overflow: hidden; }
#controls { position: fixed; top: 12px; left: 12px; z-index: 10; display: flex; gap: 8px; align-items: center; }
#controls button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
#controls button:hover { background: #30363d; }
#title { position: fixed; top: 12px; right: 16px; z-index: 10; text-align: right; }
#title h1 { font-size: 18px; font-weight: 600; color: #e6edf3; }
#title p { font-size: 12px; color: #7d8590; margin-top: 2px; }
#legend { position: fixed; bottom: 16px; left: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; line-height: 1.5; }
#legend .section { margin-bottom: 8px; }
#legend .section:last-child { margin-bottom: 0; }
#legend .section-title { color: #484f58; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }
#legend .item { display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
#legend .dot { border-radius: 50%; flex-shrink: 0; }
#legend .size-dot { background: #484f58; }
#stats { position: fixed; bottom: 16px; right: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; text-align: right; }
#stats .num { font-size: 20px; font-weight: 700; }
#tooltip { position: fixed; pointer-events: none; background: #1c2128; border: 1px solid #444c56; border-radius: 8px; padding: 12px 16px; font-size: 13px; max-width: 480px; z-index: 100; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
#tooltip .tt-name { font-weight: 700; font-size: 15px; color: #e6edf3; margin-bottom: 4px; }
#tooltip .tt-file { font-size: 11px; color: #7d8590; margin-bottom: 6px; }
#tooltip .tt-sig { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 11px; color: #a5d6ff; background: #0d1117; padding: 6px 8px; border-radius: 4px; margin-bottom: 6px; white-space: pre-wrap; word-break: break-all; max-height: 120px; overflow-y: auto; }
#tooltip .tt-desc { color: #c9d1d9; line-height: 1.4; }
#tooltip .tt-diff { margin-top: 4px; font-size: 11px; color: #7d8590; font-style: italic; }
svg { width: 100vw; height: 100vh; }
.group-rect { rx: 12; ry: 12; }
.group-label { font-size: 11px; font-weight: 600; fill: #484f58; pointer-events: none; }
.link { fill: none; }
.node-circle { cursor: pointer; stroke-width: 1.5; }
.node-circle:hover { filter: brightness(1.3); }
.node-label { font-size: 10px; fill: #8b949e; pointer-events: none; text-anchor: middle; }
#timeline { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 8px 16px; display: none; align-items: center; gap: 10px; font-size: 12px; }
#timeline button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 14px; line-height: 1; }
#timeline button:hover { background: #30363d; }
#timeline select { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 3px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; }
#timeline input[type=range] { width: 300px; accent-color: #58a6ff; }
#timeDate { color: #7d8590; width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; }
#liveBadge { background: #3fb950; color: #0d1117; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; visibility: hidden; }
</style>
</head>
<body>

<div id="controls">
  <button onclick="resetZoom()">Reset View</button>
  <button onclick="toggleLabels()">Toggle Labels</button>
</div>

<div id="title">
  <h1>AKS Sorting Network</h1>
  <p>Lean 4 Proof Dependency Graph</p>
</div>

<div id="legend">
  <div class="section">
    <div class="section-title">Status</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#3fb950;"></div> Proved</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#d29922;"></div> Sorry</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#f85149;"></div> Axiom</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#58a6ff;"></div> Definition</div>
  </div>
  <div class="section">
    <div class="section-title">Est. duration</div>
    <div class="item"><div class="dot size-dot" style="width:8px;height:8px;"></div> done / n/a</div>
    <div class="item"><div class="dot size-dot" style="width:12px;height:12px;"></div> days</div>
    <div class="item"><div class="dot size-dot" style="width:16px;height:16px;"></div> weeks</div>
    <div class="item"><div class="dot size-dot" style="width:22px;height:22px;"></div> months</div>
  </div>
  <div class="section">
    <div class="item" style="color:#484f58;">
      <svg width="32" height="12"><line x1="0" y1="6" x2="24" y2="6" stroke="#484f58" stroke-width="1.5"/><polygon points="24,3 30,6 24,9" fill="#484f58"/></svg>
      depends on
    </div>
  </div>
</div>

<div id="stats"></div>
<div id="tooltip"></div>

<div id="timeline">
  <button id="playBtn" onclick="togglePlay()">&#9654;</button>
  <select id="speedSelect" onchange="updateSpeed()">
    <option value="500">1&times;</option>
    <option value="200" selected>2&times;</option>
    <option value="100">5&times;</option>
  </select>
  <input type="range" id="timeSlider" min="0" max="0" value="0" oninput="scrubTo(this.value)">
  <span id="timeDate">Current</span>
  <span id="liveBadge">LIVE</span>
</div>

<svg></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════
// PROOF_DATA — update this block to refresh the visualization
// ═══════════════════════════════════════════════════════
const PROOF_DATA = {
  repo: "https://github.com/girving/aks",
  nodes: [
    // ── Fin.lean ──
    { id: "Fin.pair_lt", file: "AKS/Fin.lean", line: 13, status: "proved", kind: "theorem",
      sig: "Fin.pair_lt : j.val * d + i.val < n * d",
      desc: "Product encoding bound for Fin n x Fin d." },

    // ── RegularGraph.lean ──
    { id: "RegularGraph", file: "AKS/RegularGraph.lean", line: 35, status: "definition", kind: "structure",
      sig: "structure RegularGraph (n d : ℕ) where\n  rot : Fin n × Fin d → Fin n × Fin d\n  rot_involution : ...",
      desc: "D-regular graph on n vertices, represented by an involutory rotation map on vertex-port pairs." },
    { id: "walkCLM", file: "AKS/RegularGraph.lean", line: 130, status: "definition", kind: "def",
      sig: "RegularGraph.walkCLM : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Walk operator as a continuous linear map: averages a function over neighbors." },
    { id: "meanCLM", file: "AKS/RegularGraph.lean", line: 163, status: "definition", kind: "def",
      sig: "meanCLM (n : ℕ) : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Mean projection CLM: projects onto the constant-function subspace." },
    { id: "meanCLM_idempotent", file: "AKS/RegularGraph.lean", line: 173, status: "proved", kind: "theorem",
      sig: "meanCLM_idempotent : meanCLM n * meanCLM n = meanCLM n",
      desc: "Mean projection is idempotent (P² = P)." },
    { id: "meanCLM_isSelfAdjoint", file: "AKS/RegularGraph.lean", line: 184, status: "proved", kind: "theorem",
      sig: "meanCLM_isSelfAdjoint : IsSelfAdjoint (meanCLM n)",
      desc: "Mean projection is self-adjoint." },
    { id: "spectralGap", file: "AKS/RegularGraph.lean", line: 263, status: "definition", kind: "def",
      sig: "spectralGap (G : RegularGraph n d) : ℝ := ‖G.walkCLM - meanCLM n‖",
      desc: "Spectral gap: operator norm of walk minus mean projection." },
    { id: "spectralGap_nonneg", file: "AKS/RegularGraph.lean", line: 267, status: "proved", kind: "theorem",
      sig: "spectralGap_nonneg : 0 ≤ spectralGap G",
      desc: "Spectral gap is non-negative (norm is non-negative)." },
    { id: "spectralGap_le_one", file: "AKS/RegularGraph.lean", line: 330, status: "proved", kind: "theorem",
      sig: "spectralGap_le_one : spectralGap G ≤ 1",
      desc: "Spectral gap is at most 1. Proved via walk contraction and WP = P factoring." },

    // ── Square.lean ──
    { id: "RegularGraph.square", file: "AKS/Square.lean", line: 39, status: "definition", kind: "def",
      sig: "RegularGraph.square : RegularGraph n (d * d)",
      desc: "Squared graph: two-step walks become single edges. Degree goes from d to d*d." },
    { id: "spectralGap_square", file: "AKS/Square.lean", line: 182, status: "proved", kind: "theorem",
      sig: "spectralGap_square : spectralGap G.square = (spectralGap G) ^ 2",
      desc: "Squaring a graph squares its spectral gap. Key CLM identity: (W-P)^2 = W^2 - P." },

    // ── CompleteGraph.lean ──
    { id: "completeGraph", file: "AKS/CompleteGraph.lean", line: 30, status: "definition", kind: "def",
      sig: "completeGraph (n : ℕ) : RegularGraph (n + 1) n",
      desc: "Complete graph K_{n+1} as an n-regular graph, using Fin.succAbove/predAbove." },
    { id: "spectralGap_complete", file: "AKS/CompleteGraph.lean", line: 112, status: "proved", kind: "theorem",
      sig: "spectralGap_complete : spectralGap (completeGraph n) = 1 / n",
      desc: "The complete graph K_{n+1} has spectral gap exactly 1/n." },

    // ── Mixing.lean ──
    { id: "indicatorVec", file: "AKS/Mixing.lean", line: 24, status: "definition", kind: "def",
      sig: "indicatorVec (S : Finset (Fin n)) : EuclideanSpace ℝ (Fin n)",
      desc: "Indicator vector: 1 on vertices in S, 0 elsewhere." },
    { id: "expander_mixing_lemma", file: "AKS/Mixing.lean", line: 120, status: "proved", kind: "theorem",
      sig: "expander_mixing_lemma : |edges(S,T)/d - |S||T|/n| ≤ λ · √(|S|·|T|)",
      desc: "Expander mixing lemma: edge distribution between sets S,T is close to uniform, controlled by spectral gap." },

    // ── Basic.lean — Sorting Networks ──
    { id: "Comparator", file: "AKS/Basic.lean", line: 36, status: "definition", kind: "structure",
      sig: "structure Comparator (n : ℕ) where\n  i : Fin n\n  j : Fin n",
      desc: "A comparator: swaps elements at positions i and j if out of order." },
    { id: "ComparatorNetwork", file: "AKS/Basic.lean", line: 50, status: "definition", kind: "structure",
      sig: "structure ComparatorNetwork (n : ℕ) where\n  comparators : List (Comparator n)",
      desc: "A comparator network: a sequence of comparators applied in order." },
    { id: "IsSortingNetwork", file: "AKS/Basic.lean", line: 196, status: "definition", kind: "def",
      sig: "IsSortingNetwork (net : ComparatorNetwork n) : Prop",
      desc: "Predicate: the network sorts every input." },
    { id: "zero_one_principle", file: "AKS/Basic.lean", line: 206, status: "proved", kind: "theorem",
      sig: "zero_one_principle : (∀ v : Fin n → Bool, Monotone (net.exec v)) → IsSortingNetwork net",
      desc: "The 0-1 principle: if a comparator network sorts all Boolean inputs, it sorts everything." },
    { id: "AKS", file: "AKS/Basic.lean", line: 250, status: "sorry", kind: "def",
      sig: "AKS (n : ℕ) : ComparatorNetwork n",
      desc: "The AKS sorting network construction: split, recurse, merge with halvers." },
    { id: "AKS.size_nlogn", file: "AKS/Basic.lean", line: 273, status: "sorry", kind: "theorem",
      sig: "AKS.size_nlogn : (fun n ↦ (AKS n).size) =O(fun n ↦ n * log n)",
      desc: "The AKS network has O(n log n) comparators." },
    { id: "AKS.sorts", file: "AKS/Basic.lean", line: 289, status: "sorry", kind: "theorem",
      sig: "AKS.sorts (n : ℕ) : IsSortingNetwork (AKS n)",
      desc: "The AKS construction produces a valid sorting network." },

    // ── Halver.lean ──
    { id: "IsEpsilonHalver", file: "AKS/Halver.lean", line: 33, status: "definition", kind: "def",
      sig: "IsEpsilonHalver (net : ComparatorNetwork n) (ε : ℝ) : Prop",
      desc: "ε-halver: ones in top half ≤ totalOnes/2 + ε·(n/2)." },
    { id: "expander_gives_halver", file: "AKS/Halver.lean", line: 250, status: "proved", kind: "theorem",
      sig: "expander_gives_halver (G : RegularGraph m d) (β : ℝ) (hβ : spectralGap G ≤ β) :\n  ∃ net, IsEpsilonHalver net β ∧ net.size ≤ m * d",
      desc: "An expander with spectral gap ≤ β yields a β-halver. Bridge from spectral to combinatorial. Proved via bipartite comparator construction + expander mixing lemma." },
    { id: "epsHalverMerge", file: "AKS/Halver.lean", line: 366, status: "definition", kind: "def",
      sig: "epsHalverMerge (n ε : ℝ) (k : ℕ) (halver : ComparatorNetwork n) : ComparatorNetwork n",
      desc: "Iterated halver merge: apply halver k times for geometric convergence." },
    { id: "IsEpsilonSorted", file: "AKS/Halver.lean", line: 418, status: "definition", kind: "def",
      sig: "IsEpsilonSorted (v : Fin n → Bool) (ε : ℝ) : Prop",
      desc: "ε-sortedness: at most ε·n elements are out of place." },
    { id: "Monotone.bool_pattern", file: "AKS/Halver.lean", line: 432, status: "proved", kind: "lemma",
      sig: "Monotone.bool_pattern (w : Fin n → Bool) (hw : Monotone w) :\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w ⟨i, ·⟩ = false) ∧ (∀ i, k ≤ i → w ⟨i, ·⟩ = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: a prefix of falses followed by trues. Threshold found via Nat.find." },
    // NOTE: wrongness, halver_decreases_wrongness, halver_composition, halver_convergence
    // have been deleted — superseded by tree-based approach in TreeSorting.lean

    // ── ZigZagOperators.lean ──
    { id: "RegularGraph.zigzag", file: "AKS/ZigZagOperators.lean", line: 284, status: "definition", kind: "def",
      sig: "RegularGraph.zigzag (G₁ : RegularGraph n₁ d₁) (G₂ : RegularGraph d₁ d₂) :\n  RegularGraph (n₁ * d₁) (d₂ * d₂)",
      desc: "Zig-zag product: combines a big graph G₁ with a small graph G₂. Three-step walk: zig, step, zag." },
    { id: "withinClusterCLM", file: "AKS/ZigZagOperators.lean", line: 146, status: "definition", kind: "def",
      sig: "withinClusterCLM (G₂ : RegularGraph d₁ d₂) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Within-cluster walk operator B = I ⊗ W_{G₂}: walks within each cluster using G₂." },
    { id: "stepPermCLM", file: "AKS/ZigZagOperators.lean", line: 185, status: "definition", kind: "def",
      sig: "stepPermCLM (G₁ : RegularGraph n₁ d₁) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Step permutation operator Σ: permutes via G₁.rot, swapping between clusters." },
    { id: "clusterMeanCLM", file: "AKS/ZigZagOperators.lean", line: 222, status: "definition", kind: "def",
      sig: "clusterMeanCLM (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Cluster mean operator Q: averages within each cluster (projects onto cluster-constant functions)." },
    { id: "zigzag_walkCLM_eq", file: "AKS/ZigZagOperators.lean", line: 325, status: "proved", kind: "theorem",
      sig: "zigzag_walkCLM_eq : (G₁.zigzag G₂).walkCLM = B * Σ * B",
      desc: "Walk factorization: the zig-zag walk operator equals B · Σ · B." },

    // ── ZigZagSpectral.lean ──
    { id: "clusterMeanCLM_idempotent", file: "AKS/ZigZagSpectral.lean", line: 22, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_idempotent : Q * Q = Q",
      desc: "Cluster mean is idempotent (it's a projection)." },
    { id: "clusterMeanCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 31, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_isSelfAdjoint : IsSelfAdjoint Q",
      desc: "Cluster mean is self-adjoint." },
    { id: "withinClusterCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 112, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_isSelfAdjoint : IsSelfAdjoint B",
      desc: "Within-cluster walk is self-adjoint (inherits from G₂)." },
    { id: "withinCluster_comp_clusterMean", file: "AKS/ZigZagSpectral.lean", line: 160, status: "proved", kind: "theorem",
      sig: "withinCluster_comp_clusterMean : B * Q = Q",
      desc: "Walking within clusters then averaging = just averaging (BQ = Q)." },
    { id: "clusterMean_comp_withinCluster", file: "AKS/ZigZagSpectral.lean", line: 179, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_withinCluster : Q * B = Q",
      desc: "Averaging then walking within clusters = just averaging (QB = Q)." },
    { id: "withinClusterCLM_norm_le_one", file: "AKS/ZigZagSpectral.lean", line: 200, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_norm_le_one : ‖B‖ ≤ 1",
      desc: "Within-cluster walk is a contraction." },
    { id: "stepPermCLM_sq_eq_one", file: "AKS/ZigZagSpectral.lean", line: 249, status: "proved", kind: "theorem",
      sig: "stepPermCLM_sq_eq_one : Σ * Σ = 1",
      desc: "Step permutation is an involution (because G₁.rot is)." },
    { id: "stepPermCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 262, status: "proved", kind: "theorem",
      sig: "stepPermCLM_isSelfAdjoint : IsSelfAdjoint Σ",
      desc: "Step permutation is self-adjoint (orthogonal involution)." },
    { id: "stepPermCLM_comp_meanCLM", file: "AKS/ZigZagSpectral.lean", line: 648, status: "proved", kind: "theorem",
      sig: "stepPermCLM_comp_meanCLM : Σ * P = P",
      desc: "Step permutation absorbs mean projection (permuting a constant is identity)." },
    { id: "withinCluster_tilde_contraction", file: "AKS/ZigZagSpectral.lean", line: 492, status: "proved", kind: "theorem",
      sig: "withinCluster_tilde_contraction : ‖B(I - Q)‖ ≤ spectralGap G₂",
      desc: "Within-cluster walk restricted to non-constant part contracts by λ(G₂). Block-diagonal argument with per-cluster spectral gap." },
    { id: "hat_block_norm", file: "AKS/ZigZagSpectral.lean", line: 582, status: "proved", kind: "theorem",
      sig: "hat_block_norm : ‖QΣQ - P‖ ≤ spectralGap G₁",
      desc: "The 'hat' operator QΣQ minus global mean is bounded by λ(G₁)." },
    { id: "meanCLM_eq_clusterMean_comp", file: "AKS/ZigZagSpectral.lean", line: 552, status: "proved", kind: "theorem",
      sig: "meanCLM_eq_clusterMean_comp : P * Q = P",
      desc: "Global mean composed with cluster mean = global mean." },
    { id: "clusterMean_comp_meanCLM", file: "AKS/ZigZagSpectral.lean", line: 567, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_meanCLM : Q * P = P",
      desc: "Cluster mean composed with global mean = global mean." },

    // ── RVWBound.lean ──
    { id: "rvwBound", file: "AKS/RVWBound.lean", line: 38, status: "definition", kind: "def",
      sig: "rvwBound (lam₁ lam₂ : ℝ) : ℝ",
      desc: "The precise Reingold-Vadhan-Wigderson bound function for zig-zag spectral composition." },
    { id: "rvwBound_mono_left", file: "AKS/RVWBound.lean", line: 192, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_left : a₁ ≤ a₂ → rvwBound a₁ b ≤ rvwBound a₂ b",
      desc: "RVW bound is monotone in the first argument." },
    { id: "rvwBound_mono_right", file: "AKS/RVWBound.lean", line: 206, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_right : b₁ ≤ b₂ → rvwBound a b₁ ≤ rvwBound a b₂",
      desc: "RVW bound is monotone in the second argument." },
    { id: "rvw_quadratic_ineq", file: "AKS/RVWBound.lean", line: 725, status: "sorry", kind: "lemma",
      sig: "rvw_quadratic_ineq : (p+2q+r)² ≤ (1-μ₂²)μ₁|p+2q+r| + μ₂²",
      desc: "Core quadratic inequality for RVW bound. Needs manual polynomial factoring (nlinarith exceeds heartbeat limit).", difficulty: "days" },
    { id: "rayleigh_quotient_bound", file: "AKS/RVWBound.lean", line: 331, status: "sorry", kind: "lemma",
      sig: "rayleigh_quotient_bound : ‖A‖ = sSup (range (fun x ↦ |⟨Ax, x⟩|))",
      desc: "Rayleigh quotient characterization of self-adjoint operator norm.", difficulty: "weeks" },
    { id: "rvw_operator_norm_bound", file: "AKS/RVWBound.lean", line: 1123, status: "proved", kind: "theorem",
      sig: "rvw_operator_norm_bound : ‖W - P‖ ≤ rvwBound lam₁ lam₂",
      desc: "Core RVW bound: abstract operator inequality from projection/contraction axioms. Uses hat/tilde decomposition, reflection Rayleigh quotients, and the RVW quadratic inequality." },

    // ── Random.lean ──
    { id: "baseExpander", file: "AKS/Random.lean", line: 99, status: "axiom", kind: "axiom",
      sig: "axiom baseExpander : RegularGraph 20736 12",
      desc: "Base expander: 12-regular graph on 20736 = 12^4 vertices. Axiomatized (certificate is infeasible)." },
    { id: "baseExpander_gap", file: "AKS/Random.lean", line: 108, status: "axiom", kind: "axiom",
      sig: "axiom baseExpander_gap : spectralGap baseExpander ≤ 5/9",
      desc: "Base expander has spectral gap ≤ 5/9 ≈ 0.556 (just above Alon-Boppana bound)." },

    // ── ZigZag.lean ──
    { id: "zigzag_spectral_bound", file: "AKS/ZigZag.lean", line: 31, status: "proved", kind: "theorem",
      sig: "zigzag_spectral_bound : spectralGap (G₁.zigzag G₂) ≤ rvwBound lam₁ lam₂",
      desc: "Zig-zag spectral composition: assembles all sublemmas into the final bound. Degenerate case (n₁·d₁=0) handled via rvwBound ≥ 0; main case chains through rvw_operator_norm_bound." },
    { id: "zigzagFamily", file: "AKS/ZigZag.lean", line: 124, status: "definition", kind: "def",
      sig: "zigzagFamily (H₀ : RegularGraph ((D*D)*(D*D)) D) : ℕ → Σ n, RegularGraph n (D*D)",
      desc: "Iterated zig-zag construction: square then zig-zag with base, producing growing expander families." },
    { id: "zigzagFamily_gap", file: "AKS/ZigZag.lean", line: 138, status: "proved", kind: "theorem",
      sig: "zigzagFamily_gap : spectralGap (zigzagFamily H₀ k).2 ≤ c",
      desc: "Every graph in the zig-zag family has spectral gap ≤ c. Proved by induction using squaring + zig-zag bounds." },
    { id: "explicit_expanders_exist_zigzag", file: "AKS/ZigZag.lean", line: 166, status: "sorry", kind: "theorem",
      sig: "explicit_expanders_exist_zigzag :\n  ∀ n > 0, ∃ G : RegularGraph n (D*D), spectralGap G ≤ c",
      desc: "Explicit expanders exist at every size via interpolation from the zig-zag family.", difficulty: "weeks" },

    // ── AKS.lean ──
    { id: "zigzag_implies_aks_network", file: "AKS.lean", line: 21, status: "sorry", kind: "theorem",
      sig: "zigzag_implies_aks_network :\n  (∃ d, ∀ n > 0, ∃ G, spectralGap G ≤ 99/100) →\n  ∃ c > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ c·n·log n",
      desc: "Top-level theorem: explicit expander families imply O(n log n) sorting networks." },

    // ── TreeSorting.lean ──
    { id: "TreeNode", file: "AKS/TreeSorting.lean", line: 105, status: "definition", kind: "structure",
      sig: "structure TreeNode where\n  level : ℕ\n  index : ℕ",
      desc: "Position (level, index) in binary tree for register assignment." },
    { id: "treeWrongness", file: "AKS/TreeSorting.lean", line: 1485, status: "definition", kind: "def",
      sig: "treeWrongness (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : ℝ",
      desc: "Tree-based wrongness measure Δᵣ(J): proportion of elements at tree-distance ≥ r from their target." },
    { id: "halver_preserves_monotone", file: "AKS/TreeSorting.lean", line: 2449, status: "proved", kind: "lemma",
      sig: "halver_preserves_monotone : IsEpsilonHalver net ε → Monotone w → Monotone (net.exec w)",
      desc: "Applying an ε-halver to a monotone sequence preserves monotonicity." },
    { id: "monotone_bool_zeros_then_ones", file: "AKS/TreeSorting.lean", line: 1354, status: "proved", kind: "lemma",
      sig: "monotone_bool_zeros_then_ones : Monotone w →\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w i = false) ∧ (∀ i, k ≤ i → w i = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: threshold detected via Nat.find.", difficulty: "days" },
    { id: "halver_balances_ones", file: "AKS/TreeSorting.lean", line: 1952, status: "proved", kind: "lemma",
      sig: "halver_balances_ones : IsEpsilonHalver net ε →\n  onesInTop ≤ totalOnes / 2 + ε * (n / 2)",
      desc: "Direct restatement of IsEpsilonHalver: ones in top half bounded after halving." },
    { id: "countOnes_le", file: "AKS/TreeSorting.lean", line: 906, status: "proved", kind: "lemma",
      sig: "countOnes_le : countOnes v ≤ n",
      desc: "Count of ones bounded by total elements (filter cardinality)." },
    { id: "countOnes_split", file: "AKS/TreeSorting.lean", line: 1311, status: "proved", kind: "lemma",
      sig: "countOnes_split : countOnes v =\n  countOnesInRange v 0 (n/2) + countOnesInRange v (n/2) n",
      desc: "Partition count by ranges using Finset.card_union_of_disjoint.", difficulty: "days" },
    { id: "comparator_displacement_bound", file: "AKS/TreeSorting.lean", line: 2086, status: "proved", kind: "lemma",
      sig: "comparator_displacement_bound :\n  #{i | c.apply v i ≠ v i} ≤ 2",
      desc: "Comparators change at most 2 positions (subset reasoning).", difficulty: "days" },
    { id: "halver_bounds_top_excess", file: "AKS/TreeSorting.lean", line: 1996, status: "proved", kind: "lemma",
      sig: "halver_bounds_top_excess :\n  countOnesInRange (net.exec v) 0 (n/2) ≤ countOnes (net.exec v) / 2 + ε * (n / 2)",
      desc: "Output top half ones bounded (filter equivalence).", difficulty: "days" },
    { id: "halver_implies_nearsort_property", file: "AKS/TreeSorting.lean", line: 1078, status: "sorry", kind: "lemma",
      sig: "halver_implies_nearsort_property : IsEpsilonHalver net ε₁ → ε₁ << ε →\n  (1-ε) fraction move correctly, ε fraction exceptions",
      desc: "THE KEY connection: halver balance → ε-nearsort forcing property. Requires recursive nearsort correctness.", difficulty: "weeks" },
    { id: "zig_step_bounded_increase", file: "AKS/TreeSorting.lean", line: 2588, status: "sorry", kind: "lemma",
      sig: "zig_step_bounded_increase :\n  treeWrongness v' J r ≤ 8·A·(treeWrongness v J r + ε·treeWrongness v J (r-2))",
      desc: "Lemma 2: Single zig/zag step increases wrongness by bounded factor 8A.", difficulty: "weeks" }
  ],

  // Edges: [source, target] means "target depends on source" (arrow points from source to target)
  edges: [
    // RegularGraph foundations
    ["RegularGraph", "walkCLM"],
    ["RegularGraph", "meanCLM"],
    ["walkCLM", "spectralGap"],
    ["meanCLM", "spectralGap"],
    ["spectralGap", "spectralGap_nonneg"],
    ["spectralGap", "spectralGap_le_one"],
    ["walkCLM", "spectralGap_le_one"],
    ["meanCLM", "spectralGap_le_one"],

    // Mean projection properties
    ["meanCLM", "meanCLM_idempotent"],
    ["meanCLM", "meanCLM_isSelfAdjoint"],

    // Square
    ["RegularGraph", "RegularGraph.square"],
    ["spectralGap", "spectralGap_square"],
    ["RegularGraph.square", "spectralGap_square"],
    ["walkCLM", "spectralGap_square"],
    ["meanCLM", "spectralGap_square"],
    ["meanCLM_idempotent", "spectralGap_square"],
    ["meanCLM_isSelfAdjoint", "spectralGap_square"],

    // Complete graph
    ["RegularGraph", "completeGraph"],
    ["spectralGap", "spectralGap_complete"],
    ["completeGraph", "spectralGap_complete"],

    // Mixing lemma
    ["spectralGap", "expander_mixing_lemma"],
    ["walkCLM", "expander_mixing_lemma"],
    ["indicatorVec", "expander_mixing_lemma"],
    ["RegularGraph", "expander_mixing_lemma"],

    // Sorting network basics
    ["Comparator", "ComparatorNetwork"],
    ["ComparatorNetwork", "IsSortingNetwork"],
    ["ComparatorNetwork", "zero_one_principle"],
    ["IsSortingNetwork", "zero_one_principle"],

    // Halver theory
    ["ComparatorNetwork", "IsEpsilonHalver"],
    ["RegularGraph", "expander_gives_halver"],
    ["spectralGap", "expander_gives_halver"],
    ["IsEpsilonHalver", "expander_gives_halver"],
    ["expander_mixing_lemma", "expander_gives_halver"],
    ["IsEpsilonHalver", "epsHalverMerge"],
    ["ComparatorNetwork", "epsHalverMerge"],
    ["IsEpsilonSorted", "Monotone.bool_pattern"],
    // Edges to deleted nodes (wrongness, halver_composition, etc.) removed

    // Zig-zag operators
    ["RegularGraph", "RegularGraph.zigzag"],
    ["walkCLM", "withinClusterCLM"],
    ["RegularGraph", "stepPermCLM"],
    ["meanCLM", "clusterMeanCLM"],
    ["Fin.pair_lt", "withinClusterCLM"],
    ["Fin.pair_lt", "stepPermCLM"],
    ["Fin.pair_lt", "clusterMeanCLM"],
    ["withinClusterCLM", "zigzag_walkCLM_eq"],
    ["stepPermCLM", "zigzag_walkCLM_eq"],
    ["RegularGraph.zigzag", "zigzag_walkCLM_eq"],

    // Zig-zag spectral properties
    ["clusterMeanCLM", "clusterMeanCLM_idempotent"],
    ["clusterMeanCLM", "clusterMeanCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinClusterCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "withinClusterCLM_norm_le_one"],
    ["stepPermCLM", "stepPermCLM_sq_eq_one"],
    ["stepPermCLM", "stepPermCLM_isSelfAdjoint"],
    ["stepPermCLM", "stepPermCLM_comp_meanCLM"],
    ["meanCLM", "stepPermCLM_comp_meanCLM"],
    ["withinClusterCLM", "withinCluster_tilde_contraction"],
    ["clusterMeanCLM", "withinCluster_tilde_contraction"],
    ["spectralGap", "withinCluster_tilde_contraction"],
    ["stepPermCLM", "hat_block_norm"],
    ["clusterMeanCLM", "hat_block_norm"],
    ["meanCLM", "hat_block_norm"],
    ["spectralGap", "hat_block_norm"],
    ["meanCLM_eq_clusterMean_comp", "hat_block_norm"],
    ["clusterMean_comp_meanCLM", "hat_block_norm"],
    ["meanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "clusterMean_comp_meanCLM"],
    ["meanCLM", "clusterMean_comp_meanCLM"],

    // RVW bound
    ["rvwBound", "rvwBound_mono_left"],
    ["rvwBound", "rvwBound_mono_right"],
    ["rvwBound", "rvw_quadratic_ineq"],
    ["rvw_quadratic_ineq", "rvw_operator_norm_bound"],
    ["rayleigh_quotient_bound", "rvw_operator_norm_bound"],

    // Zig-zag assembly
    ["zigzag_walkCLM_eq", "zigzag_spectral_bound"],
    ["clusterMeanCLM_idempotent", "zigzag_spectral_bound"],
    ["clusterMeanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinClusterCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_comp_clusterMean", "zigzag_spectral_bound"],
    ["clusterMean_comp_withinCluster", "zigzag_spectral_bound"],
    ["withinClusterCLM_norm_le_one", "zigzag_spectral_bound"],
    ["stepPermCLM_sq_eq_one", "zigzag_spectral_bound"],
    ["stepPermCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["stepPermCLM_comp_meanCLM", "zigzag_spectral_bound"],
    ["meanCLM_idempotent", "zigzag_spectral_bound"],
    ["meanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_tilde_contraction", "zigzag_spectral_bound"],
    ["hat_block_norm", "zigzag_spectral_bound"],
    ["meanCLM_eq_clusterMean_comp", "zigzag_spectral_bound"],
    ["clusterMean_comp_meanCLM", "zigzag_spectral_bound"],
    ["rvw_operator_norm_bound", "zigzag_spectral_bound"],

    // Iterated construction
    ["RegularGraph.square", "zigzagFamily"],
    ["RegularGraph.zigzag", "zigzagFamily"],
    ["zigzag_spectral_bound", "zigzagFamily_gap"],
    ["spectralGap_square", "zigzagFamily_gap"],
    ["rvwBound_mono_left", "zigzagFamily_gap"],
    ["rvwBound_mono_right", "zigzagFamily_gap"],
    ["zigzagFamily", "zigzagFamily_gap"],
    ["zigzagFamily_gap", "explicit_expanders_exist_zigzag"],
    ["zigzagFamily", "explicit_expanders_exist_zigzag"],

    // Base expander
    ["RegularGraph", "baseExpander"],
    ["spectralGap", "baseExpander_gap"],
    ["baseExpander", "baseExpander_gap"],

    // Top-level AKS construction
    ["zero_one_principle", "AKS.sorts"],
    ["aks_tree_sorting", "AKS.sorts"],
    ["AKS", "AKS.sorts"],
    ["IsSortingNetwork", "AKS.sorts"],
    ["aks_tree_sorting", "AKS"],
    ["expander_gives_halver", "AKS"],
    ["epsHalverMerge", "AKS"],
    ["AKS", "AKS.size_nlogn"],

    // Top-level theorem
    ["explicit_expanders_exist_zigzag", "zigzag_implies_aks_network"],
    ["AKS.sorts", "zigzag_implies_aks_network"],
    ["AKS.size_nlogn", "zigzag_implies_aks_network"],
    ["baseExpander_gap", "zigzag_implies_aks_network"],

    // TreeSorting — edges FROM main proof chain into TreeSorting
    ["IsEpsilonHalver", "halver_balances_ones"],
    ["IsEpsilonHalver", "halver_preserves_monotone"],
    ["IsEpsilonHalver", "halver_implies_nearsort_property"],
    ["Comparator", "comparator_displacement_bound"],

    // TreeSorting — internal edges
    ["TreeNode", "treeWrongness"],
    ["halver_balances_ones", "halver_bounds_top_excess"],
    ["countOnes_le", "countOnes_split"],
    ["monotone_bool_zeros_then_ones", "halver_implies_nearsort_property"],
    ["halver_preserves_monotone", "halver_implies_nearsort_property"],
    ["halver_bounds_top_excess", "halver_implies_nearsort_property"],
    ["countOnes_split", "halver_implies_nearsort_property"],
    ["halver_implies_nearsort_property", "zig_step_bounded_increase"],
    ["treeWrongness", "zig_step_bounded_increase"],
    ["comparator_displacement_bound", "zig_step_bounded_increase"],

    // TreeSorting — edges TO main proof chain
    ["aks_tree_sorting", "AKS.sorts"]
  ],

  // File groupings with display names
  groups: [
    { id: "AKS/Fin.lean", label: "Fin.lean", color: "#1a1e24" },
    { id: "AKS/RegularGraph.lean", label: "RegularGraph.lean", color: "#1a1e24" },
    { id: "AKS/Square.lean", label: "Square.lean", color: "#1a1e24" },
    { id: "AKS/CompleteGraph.lean", label: "CompleteGraph.lean", color: "#1a1e24" },
    { id: "AKS/Mixing.lean", label: "Mixing.lean", color: "#1a1e24" },
    { id: "AKS/Basic.lean", label: "Basic.lean", color: "#1a1e24" },
    { id: "AKS/Halver.lean", label: "Halver.lean", color: "#1a1e24" },
    { id: "AKS/ZigZagOperators.lean", label: "ZigZagOperators.lean", color: "#1a1e24" },
    { id: "AKS/ZigZagSpectral.lean", label: "ZigZagSpectral.lean", color: "#1a1e24" },
    { id: "AKS/RVWBound.lean", label: "RVWBound.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag.lean", label: "ZigZag.lean", color: "#1a1e24" },
    { id: "AKS/Random.lean", label: "Random.lean", color: "#1a1e24" },
    { id: "AKS/TreeSorting.lean", label: "TreeSorting.lean", color: "#1a1e24" },
    { id: "AKS.lean", label: "AKS.lean", color: "#1a1e24" }
  ]
};
// ═══════════════════════════════════════════════════════

const statusColor = {
  proved: "#3fb950",
  sorry: "#d29922",
  axiom: "#f85149",
  definition: "#58a6ff"
};

// Difficulty → radius mapping
function difficultyRadius(d) {
  if (!d) return 4;
  if (d === "days") return 6;
  if (d === "1-2 weeks" || d === "weeks") return 8;
  if (d === "2-4 weeks") return 10;
  if (d === "months") return 12;
  return 4;
}

const W = window.innerWidth;
const H = window.innerHeight;

// Compute stats
const proved = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
const sorry = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
const axiomCount = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
const defs = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
document.getElementById("stats").innerHTML =
  `<div class="num" style="color:#3fb950">${proved}</div> proved<br>` +
  `<div class="num" style="color:#d29922">${sorry}</div> sorry<br>` +
  `<div class="num" style="color:#f85149">${axiomCount}</div> axiom<br>` +
  `<div class="num" style="color:#58a6ff">${defs}</div> definitions`;

// ── Compute DAG depth (longest path from roots) ──
const nodeMap = new Map(PROOF_DATA.nodes.map(n => [n.id, n]));
const inEdges = new Map();
const outEdges = new Map();
PROOF_DATA.nodes.forEach(n => { inEdges.set(n.id, []); outEdges.set(n.id, []); });
PROOF_DATA.edges.forEach(([s, t]) => {
  if (inEdges.has(t) && outEdges.has(s)) {
    inEdges.get(t).push(s);
    outEdges.get(s).push(t);
  }
});

const depth = new Map();
function getDepth(id) {
  if (depth.has(id)) return depth.get(id);
  depth.set(id, -1);
  const parents = inEdges.get(id) || [];
  const d = parents.length === 0 ? 0 : 1 + Math.max(...parents.map(getDepth));
  depth.set(id, d);
  return d;
}
PROOF_DATA.nodes.forEach(n => getDepth(n.id));
const maxDepth = Math.max(...PROOF_DATA.nodes.map(n => depth.get(n.id)));

// ── Assign radius and initial positions ──
PROOF_DATA.nodes.forEach(n => {
  n.depth = depth.get(n.id);
  n.radius = difficultyRadius(n.difficulty);
});

// Group nodes by file for group rectangles
const fileGroups = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!fileGroups.has(n.file)) fileGroups.set(n.file, []);
  fileGroups.get(n.file).push(n);
});

// Layout: Y is INVERTED (big theorems at top, foundations at bottom)
const LAYER_H = 75;
const TOP_PAD = 60;
const GRAPH_W = 1000;
const CENTER_X = GRAPH_W / 2;

// Seed initial positions: Y by inverted depth, X spread with noise
const layers = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!layers.has(n.depth)) layers.set(n.depth, []);
  layers.get(n.depth).push(n);
});
layers.forEach((nodesInLayer, d) => {
  const count = nodesInLayer.length;
  const layerW = Math.min(GRAPH_W, count * 80);
  nodesInLayer.forEach((n, i) => {
    // Inverted: max depth at top
    n.y = TOP_PAD + (maxDepth - d) * LAYER_H;
    n.x = CENTER_X - layerW/2 + (i + 0.5) * (layerW / count);
  });
});

// ── D3 setup ──
const svg = d3.select("svg");
const g = svg.append("g");

// Arrow marker
const defs2 = svg.append("defs");
defs2.append("marker")
  .attr("id", "arrowhead")
  .attr("viewBox", "0 0 10 6")
  .attr("refX", 10)
  .attr("refY", 3)
  .attr("markerWidth", 8)
  .attr("markerHeight", 5)
  .attr("orient", "auto")
  .append("polygon")
  .attr("points", "0,0 10,3 0,6")
  .attr("fill", "#484f58");

// Zoom
const zoom = d3.zoom()
  .scaleExtent([0.15, 4])
  .on("zoom", (e) => g.attr("transform", e.transform));
svg.call(zoom);

function resetZoom() {
  const graphH = TOP_PAD + (maxDepth + 1) * LAYER_H + 40;
  const scaleX = W / (GRAPH_W + 80);
  const scaleY = (H - 20) / graphH;
  const s = Math.min(scaleX, scaleY, 1.1) * 0.9;
  const tx = (W - GRAPH_W * s) / 2;
  const ty = 10;
  svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
}

let labelsVisible = true;
function toggleLabels() {
  labelsVisible = !labelsVisible;
  g.selectAll(".node-label").attr("opacity", labelsVisible ? 1 : 0);
}

// ── Build links ──
const links = PROOF_DATA.edges
  .filter(([s, t]) => nodeMap.has(s) && nodeMap.has(t))
  .map(([s, t]) => ({ source: nodeMap.get(s), target: nodeMap.get(t) }));

// ── Force simulation for organic layout ──
// Strong Y force keeps depth ordering; charge + collision spread nodes apart
const simulation = d3.forceSimulation(PROOF_DATA.nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(50).strength(0.15))
  .force("charge", d3.forceManyBody().strength(-120))
  .force("y", d3.forceY().y(d => TOP_PAD + (maxDepth - d.depth) * LAYER_H).strength(0.85))
  .force("x", d3.forceX(CENTER_X).strength(0.03))
  .force("collision", d3.forceCollide().radius(d => d.radius + 14))
  .alphaDecay(0.025)
  .alpha(0.8);

// Save layout positions after simulation settles
let simulationDone = false;
const groupCentroids = new Map();
let currentSnapshotIndex = null; // null = live mode

simulation.on("end", () => {
  PROOF_DATA.nodes.forEach(d => { d.liveX = d.x; d.liveY = d.y; });
  fileGroups.forEach((nodes, fileId) => {
    groupCentroids.set(fileId, {
      x: nodes.reduce((s, n) => s + n.liveX, 0) / nodes.length,
      y: nodes.reduce((s, n) => s + n.liveY, 0) / nodes.length,
    });
  });
  simulationDone = true;
});

function isNodeVisible(id) {
  if (currentSnapshotIndex === null || !HISTORY_DATA) return true;
  if (currentSnapshotIndex >= HISTORY_DATA.snapshots.length) return true;
  return !!HISTORY_DATA.snapshots[currentSnapshotIndex].nodes[id];
}

// ── Draw group rects (updated on tick) ──
const groupRects = g.append("g").selectAll("rect")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("rect")
  .attr("class", "group-rect")
  .attr("fill", d => d.color)
  .attr("stroke", "#21262d")
  .attr("stroke-width", 1);

const groupLabels = g.append("g").selectAll("text")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("text")
  .attr("class", "group-label")
  .text(d => d.label);

// ── Draw edges ──
const linkSel = g.append("g")
  .selectAll("path")
  .data(links)
  .join("path")
  .attr("class", "link")
  .attr("stroke", "#30363d")
  .attr("stroke-width", 1.2)
  .attr("opacity", 0.3)
  .attr("marker-end", "url(#arrowhead)");

// ── Draw nodes ──
const nodeSel = g.append("g")
  .selectAll("circle")
  .data(PROOF_DATA.nodes)
  .join("circle")
  .attr("class", "node-circle")
  .attr("r", d => d.radius)
  .attr("fill", d => statusColor[d.status])
  .attr("stroke", d => d3.color(statusColor[d.status]).darker(0.5).formatHex())
  .call(d3.drag()
    .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.15).restart(); d.fx = d.x; d.fy = d.y; })
    .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
    .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
  );

// ── Node labels ──
const labelSel = g.append("g")
  .selectAll("text")
  .data(PROOF_DATA.nodes)
  .join("text")
  .attr("class", "node-label")
  .text(d => {
    let name = d.id;
    name = name.replace("RegularGraph.", "").replace("CLM", "");
    if (name.length > 22) name = name.substring(0, 20) + "..";
    return name;
  });

// ── Edge path helper ──
function edgePath(d) {
  const sx = d.source.x, sy = d.source.y;
  const tx = d.target.x, ty = d.target.y;
  const dx = tx - sx, dy = ty - sy;
  const len = Math.sqrt(dx*dx + dy*dy) || 1;
  // Shorten at both ends by node radii
  const sr = d.source.radius + 2;
  const tr = d.target.radius + 5; // extra for arrowhead
  const bx = sx + (dx/len)*sr, by = sy + (dy/len)*sr;
  const ex = tx - (dx/len)*tr, ey = ty - (dy/len)*tr;
  // Gentle curve
  const mx = (bx + ex) / 2, my = (by + ey) / 2;
  const offset = (ex - bx) * 0.12;
  return `M${bx},${by} Q${mx + offset},${my} ${ex},${ey}`;
}

// ── Tick ──
simulation.on("tick", () => {
  linkSel.attr("d", edgePath);

  nodeSel.attr("cx", d => d.x).attr("cy", d => d.y);

  labelSel
    .attr("x", d => d.x)
    .attr("y", d => d.y + d.radius + 12);

  // Update group rectangles
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    const xs = nodes.map(n => n.x), ys = nodes.map(n => n.y);
    d3.select(this)
      .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
      .attr("width", Math.max(...xs) - Math.min(...xs) + 2*pad)
      .attr("height", Math.max(...ys) - Math.min(...ys) + 2*pad);
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    d3.select(this)
      .attr("x", Math.min(...nodes.map(n => n.x)) - pad + 6)
      .attr("y", Math.min(...nodes.map(n => n.y)) - pad + 13);
  });
});

// ── Tooltip ──
const tooltip = document.getElementById("tooltip");

nodeSel.on("mouseover", (e, d) => {
  tooltip.style.display = "block";
  let html = `<div class="tt-name">${d.id}</div>`;
  html += `<div class="tt-file">${d.file}:${d.line} &mdash; <span style="color:${statusColor[d.status]}">${d.status}</span></div>`;
  html += `<div class="tt-sig">${escHtml(d.sig)}</div>`;
  html += `<div class="tt-desc">${d.desc}</div>`;
  if (d.difficulty) html += `<div class="tt-diff">Estimated difficulty: ${d.difficulty}</div>`;
  tooltip.innerHTML = html;
})
.on("mousemove", (e) => {
  let x = e.clientX + 16, y = e.clientY + 16;
  if (x + 480 > W) x = e.clientX - 496;
  if (y + 200 > H) y = e.clientY - 200;
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
})
.on("mouseout", () => { tooltip.style.display = "none"; })
.on("click", (e, d) => {
  window.open(`${PROOF_DATA.repo}/blob/main/${d.file}#L${d.line}`, "_blank");
});

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Highlight connected nodes on hover ──
nodeSel.on("mouseover.highlight", (e, d) => {
  const connected = new Set([d.id]);
  links.forEach(l => {
    if (l.source.id === d.id) connected.add(l.target.id);
    if (l.target.id === d.id) connected.add(l.source.id);
  });
  nodeSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return connected.has(n.id) ? 1 : 0.15;
  });
  labelSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return (connected.has(n.id) && labelsVisible) ? 1 : 0.05;
  });
  linkSel.attr("opacity", l => {
    if (!isNodeVisible(l.source.id) || !isNodeVisible(l.target.id)) return 0;
    return (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.04;
  });
}).on("mouseout.highlight", () => {
  // Restore timeline state
  const slider = document.getElementById('timeSlider');
  if (HISTORY_DATA && slider && parseInt(slider.value) < HISTORY_DATA.snapshots.length) {
    applySnapshot(parseInt(slider.value), false);
  } else {
    nodeSel.attr("opacity", 1);
    labelSel.attr("opacity", labelsVisible ? 1 : 0);
    linkSel.attr("opacity", 0.3);
  }
});

// ── Initial zoom to fit ──
setTimeout(() => resetZoom(), 100);

// ═══════════════════════════════════════════════════════
// TIMELINE ANIMATION — loads history.json, scrubs through proof history
// ═══════════════════════════════════════════════════════
let HISTORY_DATA = null;
let playing = false;
let playInterval = null;
let playSpeed = 200;

fetch('history.json')
  .then(r => { if (!r.ok) throw new Error('No history'); return r.json(); })
  .then(data => { HISTORY_DATA = data; initTimeline(); })
  .catch(() => { /* No history.json — static mode only */ });

function initTimeline() {
  if (!HISTORY_DATA || !HISTORY_DATA.snapshots.length) return;
  const slider = document.getElementById('timeSlider');
  slider.max = HISTORY_DATA.snapshots.length; // 0..N-1 = snapshots, N = live
  slider.value = slider.max;
  document.getElementById('timeline').style.display = 'flex';
  updateDateDisplay(parseInt(slider.max));
}

function applySnapshot(index, animated) {
  const dur = animated ? 120 : 0;
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const snapshot = isLive ? null : HISTORY_DATA.snapshots[index];
  currentSnapshotIndex = isLive ? null : index;

  // Build visibility map
  const vis = new Map();
  PROOF_DATA.nodes.forEach(d => {
    vis.set(d.id, isLive || !!snapshot.nodes[d.id]);
  });

  // Move node positions: visible → layout position, hidden → group centroid
  if (simulationDone) {
    PROOF_DATA.nodes.forEach(d => {
      if (vis.get(d.id)) {
        d.x = d.liveX;
        d.y = d.liveY;
      } else {
        const c = groupCentroids.get(d.file);
        if (c) { d.x = c.x; d.y = c.y; }
      }
    });
  }

  // Helper: optionally wrap selection in a transition.
  // When instant (dur=0), interrupt any in-progress transitions to prevent flickering.
  function tw(sel) {
    if (dur > 0) return sel.transition().duration(dur);
    sel.interrupt();
    return sel;
  }

  // Nodes: position, color, size, opacity
  tw(nodeSel)
    .attr("cx", d => d.x).attr("cy", d => d.y)
    .attr("r", d => vis.get(d.id) ? d.radius : 0)
    .attr("fill", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return statusColor[st] || statusColor[d.status];
    })
    .attr("stroke", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return d3.color(statusColor[st] || statusColor[d.status]).darker(0.5).formatHex();
    })
    .attr("opacity", d => vis.get(d.id) ? 1 : 0);

  // Labels: position and opacity
  tw(labelSel)
    .attr("x", d => d.x).attr("y", d => d.y + d.radius + 12)
    .attr("opacity", d => (vis.get(d.id) && labelsVisible) ? 1 : 0);

  // Edges: path + opacity (opacity hides arrows too, unlike stroke-opacity)
  tw(linkSel)
    .attr("d", edgePath)
    .attr("opacity", l => {
      return (isLive || (vis.get(l.source.id) && vis.get(l.target.id))) ? 0.3 : 0;
    });

  // Group rects: recompute bounds from visible nodes only
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      const xs = vn.map(n => n.x), ys = vn.map(n => n.y);
      el.attr("opacity", 1)
        .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
        .attr("width", Math.max(...xs) - Math.min(...xs) + 2 * pad)
        .attr("height", Math.max(...ys) - Math.min(...ys) + 2 * pad);
    }
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      el.attr("opacity", 1)
        .attr("x", Math.min(...vn.map(n => n.x)) - pad + 6)
        .attr("y", Math.min(...vn.map(n => n.y)) - pad + 13);
    }
  });

  // Stats and date display
  updateTimelineStats(isLive, snapshot);
  updateDateDisplay(index);
}

function updateTimelineStats(isLive, snapshot) {
  let p, s, a, df;
  if (isLive) {
    p = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
    s = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
    a = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
    df = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
  } else {
    const vals = Object.values(snapshot.nodes);
    p = vals.filter(v => v === "proved").length;
    s = vals.filter(v => v === "sorry").length;
    a = vals.filter(v => v === "axiom").length;
    df = vals.filter(v => v === "definition").length;
  }
  document.getElementById("stats").innerHTML =
    `<div class="num" style="color:#3fb950">${p}</div> proved<br>` +
    `<div class="num" style="color:#d29922">${s}</div> sorry<br>` +
    `<div class="num" style="color:#f85149">${a}</div> axiom<br>` +
    `<div class="num" style="color:#58a6ff">${df}</div> definitions`;
}

function updateDateDisplay(index) {
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const dateEl = document.getElementById('timeDate');
  const liveEl = document.getElementById('liveBadge');
  if (isLive) {
    dateEl.textContent = 'Current';
    liveEl.style.visibility = 'visible';
  } else {
    const s = HISTORY_DATA.snapshots[index];
    const d = new Date(s.date);
    const ds = d.toLocaleDateString('en-GB', {year:'numeric', month:'short', day:'numeric'});
    const msg = s.message.length > 50 ? s.message.substring(0, 47) + '...' : s.message;
    dateEl.textContent = `${ds} \u2014 ${msg}`;
    liveEl.style.visibility = 'hidden';
  }
}

function scrubTo(value) {
  applySnapshot(parseInt(value), false);
}

function advanceFrame() {
  const slider = document.getElementById('timeSlider');
  const next = parseInt(slider.value) + 1;
  if (next > parseInt(slider.max)) {
    togglePlay();
    return;
  }
  slider.value = next;
  applySnapshot(next, true);
}

function startPlaying() {
  clearInterval(playInterval);
  playInterval = setInterval(advanceFrame, playSpeed);
}

function togglePlay() {
  playing = !playing;
  document.getElementById('playBtn').innerHTML = playing ? '&#9646;&#9646;' : '&#9654;';
  if (playing) {
    const slider = document.getElementById('timeSlider');
    if (parseInt(slider.value) >= parseInt(slider.max)) {
      slider.value = 0;
      applySnapshot(0, false);
    }
    startPlaying();
  } else {
    clearInterval(playInterval);
  }
}

function updateSpeed() {
  playSpeed = parseInt(document.getElementById('speedSelect').value);
  if (playing) startPlaying();
}
</script>
</body>
</html>
