<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AKS Sorting Network — Proof Dependency Graph</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0d1117; color: #c9d1d9; overflow: hidden; }
#controls { position: fixed; top: 12px; left: 12px; z-index: 10; display: flex; gap: 8px; align-items: center; }
#controls button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
#controls button:hover { background: #30363d; }
#title { position: fixed; top: 12px; right: 16px; z-index: 10; text-align: right; }
#title h1 { font-size: 18px; font-weight: 600; color: #e6edf3; }
#title p { font-size: 12px; color: #7d8590; margin-top: 2px; }
#legend { position: fixed; bottom: 16px; left: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; line-height: 1.5; }
#legend .section { margin-bottom: 8px; }
#legend .section:last-child { margin-bottom: 0; }
#legend .section-title { color: #484f58; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }
#legend .item { display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
#legend .dot { border-radius: 50%; flex-shrink: 0; }
#legend .size-dot { background: #484f58; }
#legend-toggle { display: none; }
#stats { position: fixed; bottom: 16px; right: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; text-align: right; }
#stats .num { font-size: 20px; font-weight: 700; }
#tooltip { position: fixed; pointer-events: none; background: #1c2128; border: 1px solid #444c56; border-radius: 8px; padding: 12px 16px; font-size: 13px; max-width: 480px; z-index: 100; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
#tooltip .tt-name { font-weight: 700; font-size: 15px; color: #e6edf3; margin-bottom: 4px; }
#tooltip .tt-file { font-size: 11px; color: #7d8590; margin-bottom: 6px; }
#tooltip .tt-sig { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 11px; color: #a5d6ff; background: #0d1117; padding: 6px 8px; border-radius: 4px; margin-bottom: 6px; white-space: pre-wrap; word-break: break-all; max-height: 120px; overflow-y: auto; }
#tooltip .tt-desc { color: #c9d1d9; line-height: 1.4; }
#tooltip .tt-diff { margin-top: 4px; font-size: 11px; color: #7d8590; font-style: italic; }
#graph { width: 100vw; height: 100vh; touch-action: none; }
.group-rect { rx: 12; ry: 12; }
.group-label { font-size: 11px; font-weight: 600; fill: #484f58; pointer-events: none; }
.link { fill: none; }
.node-circle { cursor: pointer; stroke-width: 1.5; }
.node-circle:hover { filter: brightness(1.3); }
.node-label { font-size: 10px; fill: #8b949e; pointer-events: none; text-anchor: middle; }
#timeline { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 8px 16px; display: none; align-items: center; gap: 10px; font-size: 12px; }
#timeline button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 14px; line-height: 1; }
#timeline button:hover { background: #30363d; }
#timeline select { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 3px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; }
#timeline input[type=range] { width: 300px; accent-color: #58a6ff; }
#timeDate { color: #7d8590; width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; }
#liveBadge { background: #3fb950; color: #0d1117; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; visibility: hidden; }

/* ── Mobile / narrow screens ── */
@media (max-width: 600px) {
  /* Row 1: buttons */
  #controls { top: 8px; left: 8px; gap: 4px; }
  #controls button { padding: 8px 10px; font-size: 12px; min-height: 36px; }

  /* Row 2: title below buttons, subtitle hidden */
  #title { top: 50px; left: 8px; right: auto; text-align: left; }
  #title h1 { font-size: 14px; }
  #title p { display: none; }

  /* Legend: collapse behind a toggle button, below title */
  #legend { display: none; bottom: auto; top: 76px; left: 8px; padding: 10px 12px; font-size: 11px; }
  #legend.open { display: block; }
  #legend-toggle { display: block; }

  /* Stats: compact at bottom-right */
  #stats { bottom: 8px; right: 8px; padding: 8px 10px; font-size: 11px; }
  #stats .num { font-size: 16px; }

  /* Tooltip: fit within viewport */
  #tooltip { max-width: calc(100vw - 32px); left: 16px !important; right: 16px; font-size: 12px; padding: 10px 12px; pointer-events: auto; }
  #tooltip .tt-name { font-size: 14px; }
  #tooltip .tt-sig { font-size: 10px; max-height: 80px; }

  /* Timeline: full width */
  #timeline { left: 8px; right: 8px; transform: none; bottom: 8px; padding: 6px 10px; gap: 6px; flex-wrap: wrap; justify-content: center; }
  #timeline input[type=range] { width: 100%; order: 10; }
  #timeDate { width: auto; max-width: 50vw; font-size: 10px; }

  /* When timeline is visible, push stats above it */
  body.has-timeline #stats { bottom: 72px; }
}
</style>
</head>
<body>

<div id="controls">
  <button onclick="resetZoom()">Reset View</button>
  <button onclick="toggleLabels()">Toggle Labels</button>
  <button id="legend-toggle" onclick="toggleLegend()">Legend</button>
</div>

<div id="title">
  <h1>AKS Sorting Network</h1>
  <p>Lean Proof Dependency Graph</p>
</div>

<div id="legend">
  <div class="section">
    <div class="section-title">Status</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#3fb950;"></div> Proved</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#d29922;"></div> Sorry</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#f85149;"></div> Axiom</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#58a6ff;"></div> Definition</div>
  </div>
  <div class="section">
    <div class="section-title">Est. duration</div>
    <div class="item"><div class="dot size-dot" style="width:8px;height:8px;"></div> done / n/a</div>
    <div class="item"><div class="dot size-dot" style="width:12px;height:12px;"></div> days</div>
    <div class="item"><div class="dot size-dot" style="width:16px;height:16px;"></div> weeks</div>
    <div class="item"><div class="dot size-dot" style="width:22px;height:22px;"></div> months</div>
  </div>
  <div class="section">
    <div class="section-title">Edges</div>
    <div class="item">
      <svg width="32" height="12"><line x1="0" y1="6" x2="24" y2="6" stroke="#3fb950" stroke-width="1.5"/><polygon points="24,3 30,6 24,9" fill="#3fb950"/></svg>
      all proved below
    </div>
    <div class="item">
      <svg width="32" height="12"><line x1="0" y1="6" x2="24" y2="6" stroke="#d29922" stroke-width="1.5"/><polygon points="24,3 30,6 24,9" fill="#d29922"/></svg>
      sorry/axiom below
    </div>
  </div>
</div>

<div id="stats"></div>
<div id="tooltip"></div>

<div id="timeline">
  <button id="playBtn" onclick="togglePlay()">&#9654;</button>
  <select id="speedSelect" onchange="updateSpeed()">
    <option value="500">1&times;</option>
    <option value="200" selected>2&times;</option>
    <option value="100">5&times;</option>
  </select>
  <input type="range" id="timeSlider" min="0" max="0" value="0" oninput="scrubTo(this.value)">
  <span id="timeDate">Current</span>
  <span id="liveBadge">LIVE</span>
</div>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════
// PROOF_DATA — update this block to refresh the visualization
// ═══════════════════════════════════════════════════════
const PROOF_DATA = {
  repo: "https://github.com/girving/aks",
  nodes: [
    // ── Fin.lean ──
    { id: "Fin.pair_lt", file: "AKS/Fin.lean", line: 13, status: "proved", kind: "theorem",
      sig: "Fin.pair_lt : j.val * d + i.val < n * d",
      desc: "Product encoding bound for Fin n x Fin d." },

    // ── RegularGraph.lean ──
    { id: "RegularGraph", file: "AKS/RegularGraph.lean", line: 35, status: "definition", kind: "structure",
      sig: "structure RegularGraph (n d : ℕ) where\n  rot : Fin n × Fin d → Fin n × Fin d\n  rot_involution : ...",
      desc: "D-regular graph on n vertices, represented by an involutory rotation map on vertex-port pairs." },
    { id: "walkCLM", file: "AKS/RegularGraph.lean", line: 130, status: "definition", kind: "def",
      sig: "RegularGraph.walkCLM : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Walk operator as a continuous linear map: averages a function over neighbors." },
    { id: "meanCLM", file: "AKS/RegularGraph.lean", line: 163, status: "definition", kind: "def",
      sig: "meanCLM (n : ℕ) : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Mean projection CLM: projects onto the constant-function subspace." },
    { id: "meanCLM_idempotent", file: "AKS/RegularGraph.lean", line: 173, status: "proved", kind: "theorem",
      sig: "meanCLM_idempotent : meanCLM n * meanCLM n = meanCLM n",
      desc: "Mean projection is idempotent (P² = P)." },
    { id: "meanCLM_isSelfAdjoint", file: "AKS/RegularGraph.lean", line: 184, status: "proved", kind: "theorem",
      sig: "meanCLM_isSelfAdjoint : IsSelfAdjoint (meanCLM n)",
      desc: "Mean projection is self-adjoint." },
    { id: "spectralGap", file: "AKS/RegularGraph.lean", line: 263, status: "definition", kind: "def",
      sig: "spectralGap (G : RegularGraph n d) : ℝ := ‖G.walkCLM - meanCLM n‖",
      desc: "Spectral gap: operator norm of walk minus mean projection." },
    { id: "spectralGap_nonneg", file: "AKS/RegularGraph.lean", line: 267, status: "proved", kind: "theorem",
      sig: "spectralGap_nonneg : 0 ≤ spectralGap G",
      desc: "Spectral gap is non-negative (norm is non-negative)." },
    { id: "spectralGap_le_one", file: "AKS/RegularGraph.lean", line: 330, status: "proved", kind: "theorem",
      sig: "spectralGap_le_one : spectralGap G ≤ 1",
      desc: "Spectral gap is at most 1. Proved via walk contraction and WP = P factoring." },

    // ── Square.lean ──
    { id: "RegularGraph.square", file: "AKS/Square.lean", line: 39, status: "definition", kind: "def",
      sig: "RegularGraph.square : RegularGraph n (d * d)",
      desc: "Squared graph: two-step walks become single edges. Degree goes from d to d*d." },
    { id: "spectralGap_square", file: "AKS/Square.lean", line: 182, status: "proved", kind: "theorem",
      sig: "spectralGap_square : spectralGap G.square = (spectralGap G) ^ 2",
      desc: "Squaring a graph squares its spectral gap. Key CLM identity: (W-P)^2 = W^2 - P." },

    // ── CompleteGraph.lean ──
    { id: "completeGraph", file: "AKS/CompleteGraph.lean", line: 30, status: "definition", kind: "def",
      sig: "completeGraph (n : ℕ) : RegularGraph (n + 1) n",
      desc: "Complete graph K_{n+1} as an n-regular graph, using Fin.succAbove/predAbove." },
    { id: "spectralGap_complete", file: "AKS/CompleteGraph.lean", line: 112, status: "proved", kind: "theorem",
      sig: "spectralGap_complete : spectralGap (completeGraph n) = 1 / n",
      desc: "The complete graph K_{n+1} has spectral gap exactly 1/n." },

    // ── Mixing.lean ──
    { id: "indicatorVec", file: "AKS/Mixing.lean", line: 24, status: "definition", kind: "def",
      sig: "indicatorVec (S : Finset (Fin n)) : EuclideanSpace ℝ (Fin n)",
      desc: "Indicator vector: 1 on vertices in S, 0 elsewhere." },
    { id: "expander_mixing_lemma", file: "AKS/Mixing.lean", line: 120, status: "proved", kind: "theorem",
      sig: "expander_mixing_lemma : |edges(S,T)/d - |S||T|/n| ≤ λ · √(|S|·|T|)",
      desc: "Expander mixing lemma: edge distribution between sets S,T is close to uniform, controlled by spectral gap." },

    // ── ComparatorNetwork.lean — Sorting Networks ──
    { id: "Comparator", file: "AKS/ComparatorNetwork.lean", line: 24, status: "definition", kind: "structure",
      sig: "structure Comparator (n : ℕ) where\n  i : Fin n\n  j : Fin n",
      desc: "A comparator: swaps elements at positions i and j if out of order." },
    { id: "ComparatorNetwork", file: "AKS/ComparatorNetwork.lean", line: 38, status: "definition", kind: "structure",
      sig: "structure ComparatorNetwork (n : ℕ) where\n  comparators : List (Comparator n)",
      desc: "A comparator network: a sequence of comparators applied in order." },
    { id: "IsSortingNetwork", file: "AKS/ComparatorNetwork.lean", line: 184, status: "definition", kind: "def",
      sig: "IsSortingNetwork (net : ComparatorNetwork n) : Prop",
      desc: "Predicate: the network sorts every input." },
    { id: "zero_one_principle", file: "AKS/ComparatorNetwork.lean", line: 194, status: "proved", kind: "theorem",
      sig: "zero_one_principle : (∀ v : Fin n → Bool, Monotone (net.exec v)) → IsSortingNetwork net",
      desc: "The 0-1 principle: if a comparator network sorts all Boolean inputs, it sorts everything." },
    // ── AKS/AKSNetwork.lean — iterated halver helpers ──
    { id: "epsHalverMerge_exec_eq_iterate", file: "AKS/AKSNetwork.lean", line: 26, status: "proved", kind: "theorem",
      sig: "epsHalverMerge_exec_eq_iterate : (epsHalverMerge n ε k halver).exec v = Nat.iterate (fun w ↦ halver.exec w) k v",
      desc: "Executing epsHalverMerge is iterating the halver's exec." },
    { id: "epsHalverMerge_size", file: "AKS/AKSNetwork.lean", line: 39, status: "proved", kind: "theorem",
      sig: "epsHalverMerge_size : (epsHalverMerge n ε k halver).size = k * halver.size",
      desc: "Size of epsHalverMerge is k times the halver size." },
    { id: "mono_of_iterate_mono", file: "AKS/AKSNetwork.lean", line: 47, status: "proved", kind: "theorem",
      sig: "mono_of_iterate_mono : k₁ ≤ k₂ → Monotone (iterate f k₁ v) → Monotone (iterate f k₂ v)",
      desc: "If iterating k₁ times produces a monotone result, so does iterating k₂ ≥ k₁ times." },
    { id: "aks_size_bound", file: "AKS/AKSNetwork.lean", line: 81, status: "proved", kind: "theorem",
      sig: "aks_size_bound : 100 * Nat.log 2 (2*m) * s ≤ 100*(d+1)*(2*m)*log(2*m)",
      desc: "Size arithmetic for the AKS construction using Nat.log ≤ logb and log 2 > 1/2." },

    // ── Halver.lean ──
    { id: "IsEpsilonHalver", file: "AKS/Halver.lean", line: 64, status: "definition", kind: "def",
      sig: "IsEpsilonHalver (net : ComparatorNetwork n) (ε : ℝ) : Prop",
      desc: "ε-halver (AKS Section 3): segment-wise bounded displacement from sorted. Initial segments have ≤ ε·k excess, end segments have ≤ ε·(n-k) excess." },
    { id: "expander_gives_halver", file: "AKS/Halver.lean", line: 286, status: "sorry", kind: "theorem",
      sig: "expander_gives_halver (G : RegularGraph m d) (β : ℝ) (hβ : spectralGap G ≤ β) :\n  ∃ net, IsEpsilonHalver net β ∧ net.size ≤ m * d",
      desc: "An expander with spectral gap ≤ β yields a β-halver (segment-wise). Needs vertex expansion (Alon-Chung), not just mixing lemma.", difficulty: "weeks" },
    { id: "epsHalverMerge", file: "AKS/Halver.lean", line: 299, status: "definition", kind: "def",
      sig: "epsHalverMerge (n ε : ℝ) (k : ℕ) (halver : ComparatorNetwork n) : ComparatorNetwork n",
      desc: "Iterated halver merge: apply halver k times for geometric convergence." },
    { id: "IsEpsilonSorted", file: "AKS/Halver.lean", line: 351, status: "definition", kind: "def",
      sig: "IsEpsilonSorted (v : Fin n → Bool) (ε : ℝ) : Prop",
      desc: "ε-sortedness: at most ε·n elements are out of place." },
    { id: "Monotone.bool_pattern", file: "AKS/Halver.lean", line: 365, status: "proved", kind: "lemma",
      sig: "Monotone.bool_pattern (w : Fin n → Bool) (hw : Monotone w) :\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w ⟨i, ·⟩ = false) ∧ (∀ i, k ≤ i → w ⟨i, ·⟩ = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: a prefix of falses followed by trues. Threshold found via Nat.find." },
    // NOTE: wrongness, halver_decreases_wrongness, halver_composition, halver_convergence
    // have been deleted — superseded by tree-based approach in TreeSorting.lean

    // ── ZigZagOperators.lean ──
    { id: "RegularGraph.zigzag", file: "AKS/ZigZagOperators.lean", line: 284, status: "definition", kind: "def",
      sig: "RegularGraph.zigzag (G₁ : RegularGraph n₁ d₁) (G₂ : RegularGraph d₁ d₂) :\n  RegularGraph (n₁ * d₁) (d₂ * d₂)",
      desc: "Zig-zag product: combines a big graph G₁ with a small graph G₂. Three-step walk: zig, step, zag." },
    { id: "withinClusterCLM", file: "AKS/ZigZagOperators.lean", line: 146, status: "definition", kind: "def",
      sig: "withinClusterCLM (G₂ : RegularGraph d₁ d₂) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Within-cluster walk operator B = I ⊗ W_{G₂}: walks within each cluster using G₂." },
    { id: "stepPermCLM", file: "AKS/ZigZagOperators.lean", line: 185, status: "definition", kind: "def",
      sig: "stepPermCLM (G₁ : RegularGraph n₁ d₁) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Step permutation operator Σ: permutes via G₁.rot, swapping between clusters." },
    { id: "clusterMeanCLM", file: "AKS/ZigZagOperators.lean", line: 222, status: "definition", kind: "def",
      sig: "clusterMeanCLM (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Cluster mean operator Q: averages within each cluster (projects onto cluster-constant functions)." },
    { id: "zigzag_walkCLM_eq", file: "AKS/ZigZagOperators.lean", line: 325, status: "proved", kind: "theorem",
      sig: "zigzag_walkCLM_eq : (G₁.zigzag G₂).walkCLM = B * Σ * B",
      desc: "Walk factorization: the zig-zag walk operator equals B · Σ · B." },

    // ── ZigZagSpectral.lean ──
    { id: "clusterMeanCLM_idempotent", file: "AKS/ZigZagSpectral.lean", line: 22, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_idempotent : Q * Q = Q",
      desc: "Cluster mean is idempotent (it's a projection)." },
    { id: "clusterMeanCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 31, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_isSelfAdjoint : IsSelfAdjoint Q",
      desc: "Cluster mean is self-adjoint." },
    { id: "withinClusterCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 112, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_isSelfAdjoint : IsSelfAdjoint B",
      desc: "Within-cluster walk is self-adjoint (inherits from G₂)." },
    { id: "withinCluster_comp_clusterMean", file: "AKS/ZigZagSpectral.lean", line: 160, status: "proved", kind: "theorem",
      sig: "withinCluster_comp_clusterMean : B * Q = Q",
      desc: "Walking within clusters then averaging = just averaging (BQ = Q)." },
    { id: "clusterMean_comp_withinCluster", file: "AKS/ZigZagSpectral.lean", line: 179, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_withinCluster : Q * B = Q",
      desc: "Averaging then walking within clusters = just averaging (QB = Q)." },
    { id: "withinClusterCLM_norm_le_one", file: "AKS/ZigZagSpectral.lean", line: 200, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_norm_le_one : ‖B‖ ≤ 1",
      desc: "Within-cluster walk is a contraction." },
    { id: "stepPermCLM_sq_eq_one", file: "AKS/ZigZagSpectral.lean", line: 249, status: "proved", kind: "theorem",
      sig: "stepPermCLM_sq_eq_one : Σ * Σ = 1",
      desc: "Step permutation is an involution (because G₁.rot is)." },
    { id: "stepPermCLM_isSelfAdjoint", file: "AKS/ZigZagSpectral.lean", line: 262, status: "proved", kind: "theorem",
      sig: "stepPermCLM_isSelfAdjoint : IsSelfAdjoint Σ",
      desc: "Step permutation is self-adjoint (orthogonal involution)." },
    { id: "stepPermCLM_comp_meanCLM", file: "AKS/ZigZagSpectral.lean", line: 648, status: "proved", kind: "theorem",
      sig: "stepPermCLM_comp_meanCLM : Σ * P = P",
      desc: "Step permutation absorbs mean projection (permuting a constant is identity)." },
    { id: "withinCluster_tilde_contraction", file: "AKS/ZigZagSpectral.lean", line: 492, status: "proved", kind: "theorem",
      sig: "withinCluster_tilde_contraction : ‖B(I - Q)‖ ≤ spectralGap G₂",
      desc: "Within-cluster walk restricted to non-constant part contracts by λ(G₂). Block-diagonal argument with per-cluster spectral gap." },
    { id: "hat_block_norm", file: "AKS/ZigZagSpectral.lean", line: 582, status: "proved", kind: "theorem",
      sig: "hat_block_norm : ‖QΣQ - P‖ ≤ spectralGap G₁",
      desc: "The 'hat' operator QΣQ minus global mean is bounded by λ(G₁)." },
    { id: "meanCLM_eq_clusterMean_comp", file: "AKS/ZigZagSpectral.lean", line: 552, status: "proved", kind: "theorem",
      sig: "meanCLM_eq_clusterMean_comp : P * Q = P",
      desc: "Global mean composed with cluster mean = global mean." },
    { id: "clusterMean_comp_meanCLM", file: "AKS/ZigZagSpectral.lean", line: 567, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_meanCLM : Q * P = P",
      desc: "Cluster mean composed with global mean = global mean." },

    // ── RVWBound.lean ──
    { id: "rvwBound", file: "AKS/RVWBound.lean", line: 38, status: "definition", kind: "def",
      sig: "rvwBound (lam₁ lam₂ : ℝ) : ℝ",
      desc: "The precise Reingold-Vadhan-Wigderson bound function for zig-zag spectral composition." },
    { id: "rvwBound_mono_left", file: "AKS/RVWBound.lean", line: 192, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_left : a₁ ≤ a₂ → rvwBound a₁ b ≤ rvwBound a₂ b",
      desc: "RVW bound is monotone in the first argument." },
    { id: "rvwBound_mono_right", file: "AKS/RVWBound.lean", line: 206, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_right : b₁ ≤ b₂ → rvwBound a b₁ ≤ rvwBound a b₂",
      desc: "RVW bound is monotone in the second argument." },
    { id: "rvw_quadratic_ineq", file: "AKS/RVWBound.lean", line: 784, status: "sorry", kind: "lemma",
      sig: "rvw_quadratic_ineq : (p+2q+r)² ≤ (1-μ₂²)μ₁|p+2q+r| + μ₂²",
      desc: "Core quadratic inequality for RVW bound. Needs manual polynomial factoring (nlinarith exceeds heartbeat limit).", difficulty: "days" },
    { id: "rayleigh_quotient_bound", file: "AKS/RVWBound.lean", line: 331, status: "sorry", kind: "lemma",
      sig: "rayleigh_quotient_bound : ‖A‖ = sSup (range (fun x ↦ |⟨Ax, x⟩|))",
      desc: "Rayleigh quotient characterization of self-adjoint operator norm.", difficulty: "weeks" },
    { id: "rvw_operator_norm_bound", file: "AKS/RVWBound.lean", line: 1237, status: "proved", kind: "theorem",
      sig: "rvw_operator_norm_bound : ‖W - P‖ ≤ rvwBound lam₁ lam₂",
      desc: "Core RVW bound: abstract operator inequality from projection/contraction axioms. Uses hat/tilde decomposition, reflection Rayleigh quotients, and the RVW quadratic inequality." },

    // ── WalkBound.lean ──
    { id: "spectralGap_le_of_walk_bound", file: "AKS/WalkBound.lean", line: 26, status: "proved", kind: "theorem",
      sig: "spectralGap_le_of_walk_bound : (∀ f, meanCLM n f = 0 → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²) → spectralGap G ≤ √(c₁/(c₂·d²))",
      desc: "Walk bound on mean-zero vectors implies spectral gap bound via operator norm characterization." },
    { id: "sqrt_coeff_le_frac", file: "AKS/WalkBound.lean", line: 75, status: "proved", kind: "theorem",
      sig: "sqrt_coeff_le_frac : c₁·βd² ≤ c₂·βn² → √(c₁/(c₂·d²)) ≤ βn/(βd·d)",
      desc: "Coefficient arithmetic: converts walk bound ratio to rational fraction." },

    // ── SpectralMatrix.lean ──
    { id: "spectralMatrix", file: "AKS/SpectralMatrix.lean", line: 33, status: "definition", kind: "def",
      sig: "spectralMatrix G c₁ c₂ c₃ = c₁·I - c₂·A² + c₃·J\n  where A = d · adjMatrix G (unnormalized)",
      desc: "Spectral matrix M = c₁I - c₂A² + c₃J with unnormalized adjacency A = d · adjMatrix." },
    { id: "spectralMatrix_isHermitian", file: "AKS/SpectralMatrix.lean", line: 43, status: "proved", kind: "theorem",
      sig: "spectralMatrix_isHermitian : (spectralMatrix G c₁ c₂ c₃).IsHermitian",
      desc: "Spectral matrix is Hermitian (real symmetric)." },
    { id: "spectralMatrix_posSemidef_implies_walk_bound", file: "AKS/SpectralMatrix.lean", line: 119, status: "proved", kind: "theorem",
      sig: "spectralMatrix_posSemidef_implies_walk_bound :\n  M.PosSemidef → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²",
      desc: "Layer 1: PSD spectral matrix implies walk bound. Proof: PSD → nonneg quadratic form, J vanishes on mean-zero vectors, unnormalized adjacency gives d² factor." },

    // ── DiagDominant.lean ──
    { id: "diagDominant_isUnit", file: "AKS/DiagDominant.lean", line: 25, status: "proved", kind: "theorem",
      sig: "diagDominant_isUnit : (∀ k, ∑ j≠k ‖M k j‖ < ‖M k k‖) → IsUnit M",
      desc: "Strict row diagonal dominance implies invertibility via Gershgorin circle theorem." },
    { id: "diagDominant_posSemidef", file: "AKS/DiagDominant.lean", line: 55, status: "proved", kind: "theorem",
      sig: "diagDominant_posSemidef : M.IsHermitian → (∀ i, ∑ j≠i ‖M i j‖ < M i i) → M.PosSemidef",
      desc: "Layer 2: Hermitian + strict diagonal dominance implies PSD. Direct quadratic form bound via AM-GM regrouping." },

    // ── CertificateBridge.lean ──
    { id: "certMatrixReal", file: "AKS/CertificateBridge.lean", line: 36, status: "definition", kind: "def",
      sig: "certMatrixReal (certBytes : ByteArray) (n : ℕ) : Matrix (Fin n) (Fin n) ℝ",
      desc: "Certificate matrix Z decoded from base-85 bytes. Upper triangular: Z[i,j] = 0 for i > j." },
    { id: "certMatrix_posdiag", file: "AKS/CertificateBridge.lean", line: 61, status: "proved", kind: "theorem",
      sig: "certMatrix_posdiag :\n  checkPSDCertificate = true → ∀ j, 0 < Z j j",
      desc: "Certificate matrix has positive diagonal when PSD checker passes. Proved by extracting allDiagPositive check from the augmented checker via induction." },
    { id: "kRowDominant_implies_diagDominant", file: "AKS/CertificateBridge.lean", line: 389, status: "proved", kind: "theorem",
      sig: "kRowDominant_implies_diagDominant :\n  checkAllRowsDomPure = true → hmatch → ∀ i, ∑ j≠i ‖K i j‖ < K i i",
      desc: "Bridge: pure functional checker matches formal star Z * M * Z. Proved via chain: certEntry↔Z, adjMul↔unnorm_adj, pEntry↔M*Z, kEntry↔Z*M*Z, then integer diag-dominance → real." },
    { id: "checkColumnNormBound_perRow", file: "AKS/CertificateBridge.lean", line: 307, status: "sorry", kind: "theorem",
      sig: "checkColumnNormBound_perRow :\n  checkColumnNormBound = true → Z[i,i]·(δ+ε) > ε·T_i",
      desc: "Per-row column-norm inequality from imperative checker. Requires connecting Id.run do loop (Phase 3) to pure recursive epsMaxVal/minDiagVal definitions." },
    { id: "congruence_diagDominant", file: "AKS/CertificateBridge.lean", line: 489, status: "sorry", kind: "theorem",
      sig: "congruence_diagDominant :\n  checkCertificate = true → ∀ i, ∑ j≠i ‖K i j‖ < K i i",
      desc: "K = Z*MZ is strictly row-diag-dominant. Proved from checkColumnNormBound_spec (properties 1-3 proved, per-row check via checkColumnNormBound_perRow). Only transitive sorry remaining." },
    { id: "checker_implies_spectralMatrix_psd", file: "AKS/CertificateBridge.lean", line: 673, status: "proved", kind: "theorem",
      sig: "checker_implies_spectralMatrix_psd :\n  checkCertificate = true → (spectralMatrix G c₁ c₂ c₃).PosSemidef",
      desc: "Layer 3: certificate checker passes → spectral matrix PSD. Proof: Z upper-tri + pos-diag → invertible; K=Z*MZ Hermitian + diag-dominant → PSD; congruence → M PSD." },
    { id: "certificate_implies_walk_bound", file: "AKS/CertificateBridge.lean", line: 724, status: "proved", kind: "theorem",
      sig: "certificate_implies_walk_bound :\n  checkCertificate = true → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²",
      desc: "Certificate → walk bound. Chains Layer 3 (certificate → PSD) with Layer 1 (PSD → walk bound)." },
    { id: "certificate_bridge", file: "AKS/CertificateBridge.lean", line: 754, status: "proved", kind: "theorem",
      sig: "certificate_bridge :\n  checkCertificate = true → spectralGap G ≤ βn/(βd·d)",
      desc: "Full bridge: certificate → spectral gap bound. Chains walk bound, spectralGap_le_of_walk_bound, and sqrt_coeff_le_frac.", milestone: true },

    // ── Random.lean ──
    { id: "baseExpander", file: "AKS/Random.lean", line: 99, status: "axiom", kind: "axiom",
      sig: "axiom baseExpander : RegularGraph 20736 12",
      desc: "Base expander: 12-regular graph on 20736 = 12^4 vertices. Axiomatized (certificate is infeasible)." },
    { id: "baseExpander_gap", file: "AKS/Random.lean", line: 108, status: "axiom", kind: "axiom",
      sig: "axiom baseExpander_gap : spectralGap baseExpander ≤ 5/9",
      desc: "Base expander has spectral gap ≤ 5/9 ≈ 0.556 (just above Alon-Boppana bound)." },

    // ── ZigZag.lean ──
    { id: "zigzag_spectral_bound", file: "AKS/ZigZag.lean", line: 30, status: "proved", kind: "theorem",
      sig: "zigzag_spectral_bound : spectralGap (G₁.zigzag G₂) ≤ rvwBound lam₁ lam₂",
      desc: "Zig-zag spectral composition: assembles all sublemmas into the final bound. Degenerate case (n₁·d₁=0) handled via rvwBound ≥ 0; main case chains through rvw_operator_norm_bound." },
    { id: "zigzagFamily", file: "AKS/ZigZag.lean", line: 124, status: "definition", kind: "def",
      sig: "zigzagFamily (H₀ : RegularGraph ((D*D)*(D*D)) D) : ℕ → Σ n, RegularGraph n (D*D)",
      desc: "Iterated zig-zag construction: square then zig-zag with base, producing growing expander families." },
    { id: "zigzagFamily_gap", file: "AKS/ZigZag.lean", line: 138, status: "proved", kind: "theorem",
      sig: "zigzagFamily_gap : spectralGap (zigzagFamily H₀ k).2 ≤ c",
      desc: "Every graph in the zig-zag family has spectral gap ≤ c. Proved by induction using squaring + zig-zag bounds." },
    { id: "explicit_expanders_exist_zigzag", file: "AKS/ZigZag.lean", line: 168, status: "sorry", kind: "theorem",
      sig: "explicit_expanders_exist_zigzag :\n  ∀ n > 0, ∃ G : RegularGraph n (D*D), spectralGap G ≤ c",
      desc: "Explicit expanders exist at every size via interpolation from the zig-zag family.", difficulty: "weeks" },

    // ── AKS/AKSNetwork.lean — top-level parameterized theorem ──
    { id: "zigzag_implies_aks_network", file: "AKS/AKSNetwork.lean", line: 132, status: "sorry", kind: "theorem",
      sig: "zigzag_implies_aks_network {β : ℝ} (hβ_pos : 0 < β) (hβ_half : β < 1/2) :\n  (∃ d, ∀ n > 0, ∃ G, spectralGap G ≤ β) →\n  ∃ c > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ c·n·log n",
      desc: "Parameterized AKS theorem: expander family → O(n log n) sorting networks. Builds halver family via Classical.choice, calls aks_tree_sorting. No direct sorry (sorry is in aks_tree_sorting)." },

    // ── AKS/Main.lean — top-level assembly via iterated squaring ──
    { id: "squareIter", file: "AKS/Main.lean", line: 35, status: "definition", kind: "def",
      sig: "RegularGraph.squareIter (G : RegularGraph n d) :\n  (k : ℕ) → RegularGraph n (d ^ (2 ^ k))",
      desc: "Iterated graph squaring: square k times, yielding d^(2^k)-regular graph on n vertices." },
    { id: "spectralGap_squareIter", file: "AKS/Main.lean", line: 41, status: "proved", kind: "theorem",
      sig: "spectralGap_squareIter :\n  spectralGap (G.squareIter k) = (spectralGap G) ^ (2 ^ k)",
      desc: "Spectral gap of k-th iterated square is the 2^k-th power of the original gap." },
    { id: "exists_pow_two_pow_lt", file: "AKS/Main.lean", line: 54, status: "proved", kind: "theorem",
      sig: "exists_pow_two_pow_lt : 0 ≤ c → c < 1 → 0 < t → ∃ k, c ^ (2^k) < t",
      desc: "Doubly-exponential convergence: c^(2^k) eventually drops below any positive target." },
    { id: "expander_family_small_gap", file: "AKS/Main.lean", line: 66, status: "proved", kind: "theorem",
      sig: "expander_family_small_gap :\n  ... → 0 < c → c < 1 → 0 < β →\n  ∃ d, ∀ n > 0, ∃ G : RegularGraph n d, spectralGap G ≤ β",
      desc: "Zig-zag + iterated squaring gives constant-degree expander family with arbitrarily small spectral gap." },
    { id: "aks_sorting_networks_exist", file: "AKS/Main.lean", line: 106, status: "proved", kind: "theorem",
      sig: "aks_sorting_networks_exist :\n  ... → 0 < c → c < 1 →\n  ∃ C > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ C·n·log n",
      desc: "AKS (1983): O(n log n) sorting networks exist, from base expander + zig-zag + squaring + tree sorting." },

    // ── TreeSorting.lean ──
    { id: "TreeNode", file: "AKS/TreeSorting.lean", line: 105, status: "definition", kind: "structure",
      sig: "structure TreeNode where\n  level : ℕ\n  index : ℕ",
      desc: "Position (level, index) in binary tree for register assignment." },
    { id: "treeWrongness", file: "AKS/TreeSorting.lean", line: 1633, status: "definition", kind: "def",
      sig: "treeWrongness (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : ℝ",
      desc: "Tree-based wrongness measure Δᵣ(J): proportion of elements at tree-distance ≥ r from their target." },
    { id: "halver_preserves_monotone", file: "AKS/TreeSorting.lean", line: 2382, status: "proved", kind: "lemma",
      sig: "halver_preserves_monotone : IsEpsilonHalver net ε → Monotone w → Monotone (net.exec w)",
      desc: "Applying an ε-halver to a monotone sequence preserves monotonicity." },
    { id: "monotone_bool_zeros_then_ones", file: "AKS/TreeSorting.lean", line: 1502, status: "proved", kind: "lemma",
      sig: "monotone_bool_zeros_then_ones : Monotone w →\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w i = false) ∧ (∀ i, k ≤ i → w i = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: threshold detected via Nat.find.", difficulty: "days" },
    { id: "countOnes_le", file: "AKS/Halver.lean", line: 31, status: "proved", kind: "lemma",
      sig: "countOnes_le : countOnes v ≤ n",
      desc: "Count of ones bounded by total elements (filter cardinality)." },
    { id: "countOnes_split", file: "AKS/TreeSorting.lean", line: 1459, status: "proved", kind: "lemma",
      sig: "countOnes_split : countOnes v =\n  countOnesInRange v 0 (n/2) + countOnesInRange v (n/2) n",
      desc: "Partition count by ranges using Finset.card_union_of_disjoint.", difficulty: "days" },
    { id: "comparator_displacement_bound", file: "AKS/TreeSorting.lean", line: 2094, status: "proved", kind: "lemma",
      sig: "comparator_displacement_bound :\n  #{i | c.apply v i ≠ v i} ≤ 2",
      desc: "Comparators change at most 2 positions (subset reasoning).", difficulty: "days" },
    { id: "HasBoundedDamage", file: "AKS/TreeSorting.lean", line: 988, status: "definition", kind: "def",
      sig: "HasBoundedDamage (net : ComparatorNetwork n) (ε : ℝ) : Prop",
      desc: "Bounded-damage property: network increases elements at distance ≥ r by at most ε · (elements at distance ≥ r-2). Key interface between halver world and tree-sorting world.", difficulty: "done" },
    { id: "recursiveNearsort", file: "AKS/TreeSorting.lean", line: 1910, status: "definition", kind: "def",
      sig: "recursiveNearsort (n : ℕ)\n  (halvers : (m : ℕ) → ComparatorNetwork (2 * m))\n  (depth : ℕ) : ComparatorNetwork n",
      desc: "Recursive ε-nearsort from AKS Section 4. Applies halvers at each tree level (coarsest to finest) via applyHalversAtLevel." },
    { id: "nearsort_has_bounded_tree_damage", file: "AKS/TreeSorting.lean", line: 1924, status: "sorry", kind: "lemma",
      sig: "nearsort_has_bounded_tree_damage :\n  (∀ m, IsEpsilonHalver (halvers m) ε) →\n  HasBoundedTreeDamage (recursiveNearsort n halvers (log₂ n)) ε t",
      desc: "Lemma 2 (AKS Section 8): recursive nearsort with halver family → bounded tree damage. Requires segment-wise halver property.", difficulty: "weeks" },
    { id: "bounded_tree_damage_pair_gives_zigzag", file: "AKS/TreeSorting.lean", line: 1174, status: "sorry", kind: "lemma",
      sig: "bounded_tree_damage_pair_gives_zigzag :\n  HasBoundedTreeDamage zig ε t → HasBoundedTreeDamage zag ε t → HasBoundedZigzagDamage zig zag ε t",
      desc: "Lemma 3 (AKS Section 8): two BoundedTreeDamage steps (zig/zag on complementary cherry partitions) → BoundedZigzagDamage. The r→r+1 shift comes from partition offset.", difficulty: "weeks" },

    // V2 tree-distance-based definitions (Phase 1 of targeted hybrid)
    { id: "sectionIndex", file: "AKS/TreeSorting.lean", line: 840, status: "definition", kind: "def",
      sig: "sectionIndex (n t i : ℕ) : ℕ",
      desc: "Section index at level t for position i: ⌊i·2^t/n⌋. Maps positions to binary tree sections." },
    { id: "sectionNode", file: "AKS/TreeSorting.lean", line: 865, status: "definition", kind: "def",
      sig: "sectionNode (n t : ℕ) (i : Fin n) : TreeNode",
      desc: "TreeNode at level t for position i. Maps each position to its section in the binary tree." },
    { id: "positionTreeDist", file: "AKS/TreeSorting.lean", line: 1020, status: "definition", kind: "def",
      sig: "positionTreeDist (n t : ℕ) (v : Fin n → Bool) (i : Fin n) : ℕ",
      desc: "Tree displacement of position i: tree distance from i's section to threshold section at level t." },
    { id: "elementsAtTreeDist", file: "AKS/TreeSorting.lean", line: 1099, status: "definition", kind: "def",
      sig: "elementsAtTreeDist (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : Finset (Fin n)",
      desc: "Elements in J displaced at tree-distance ≥ r. Time-dependent V2 of elementsAtDistance." },
    { id: "HasBoundedTreeDamage", file: "AKS/TreeSorting.lean", line: 1129, status: "definition", kind: "def",
      sig: "HasBoundedTreeDamage (net : ComparatorNetwork n) (ε : ℝ) (t : ℕ) : Prop",
      desc: "V2 bounded-damage using tree distance. Network increases tree-dist count by ≤ ε·count(r-2)." },
    { id: "treeWrongnessV2", file: "AKS/TreeSorting.lean", line: 1648, status: "definition", kind: "def",
      sig: "treeWrongnessV2 (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : ℝ",
      desc: "V2 tree wrongness using elementsAtTreeDist. Genuinely time-dependent (depends on t via sectionNode)." },
    { id: "cherry_wrongness_after_nearsort_v2", file: "AKS/TreeSorting.lean", line: 2391, status: "proved", kind: "lemma",
      sig: "cherry_wrongness_after_nearsort_v2 :\n  treeWrongnessV2 (net.exec v) J r ≤ treeWrongnessV2 v J r + ε·treeWrongnessV2 v J (r-2)",
      desc: "V2: Cherry wrongness after nearsort. Same algebraic proof using HasBoundedTreeDamage." },
    { id: "zig_step_bounded_increase_v2", file: "AKS/TreeSorting.lean", line: 2477, status: "proved", kind: "lemma",
      sig: "zig_step_bounded_increase_v2 :\n  treeWrongnessV2 v' J r ≤ 8·A·(treeWrongnessV2 v J r + ε·treeWrongnessV2 v J (r-2))",
      desc: "V2: Zig step bounded increase. Same algebraic proof using HasBoundedTreeDamage and treeWrongnessV2." },
    { id: "positionTreeDist_succ_le", file: "AKS/TreeSorting.lean", line: 1039, status: "proved", kind: "lemma",
      sig: "positionTreeDist_succ_le :\n  positionTreeDist n (t+1) v i ≤ positionTreeDist n t v i + 2",
      desc: "Tree distance increases by at most 2 when refining from level t to t+1. Uses sectionIndex_succ_div_two and indexAtLevel agreement." },
    { id: "HasBoundedZigzagDamage", file: "AKS/TreeSorting.lean", line: 1159, status: "definition", kind: "definition",
      sig: "HasBoundedZigzagDamage zig_net zag_net ε t : Prop",
      desc: "Combined zigzag bounded-damage with r → r+1 distance shift. Key structural property of even/odd cherry alternation." },
    { id: "register_reassignment_increases_wrongness_v2", file: "AKS/TreeSorting.lean", line: 2425, status: "proved", kind: "lemma",
      sig: "register_reassignment_increases_wrongness_v2 :\n  treeWrongnessV2 (t+1) v J' r ≤ C · treeWrongnessV2 t v J (r-2)",
      desc: "V2 Lemma 1: Register reassignment. Single v, J'⊆J, distance shift 2, parameterized constant C." },
    { id: "zigzag_decreases_wrongness_v2", file: "AKS/TreeSorting.lean", line: 2534, status: "proved", kind: "lemma",
      sig: "zigzag_decreases_wrongness_v2 :\n  treeWrongnessV2 t v'' J r ≤ treeWrongnessV2 t v J (r+1) + 3ε·tw(r-4)",
      desc: "V2 Lemma 3: ZigZag combined step. Proved from HasBoundedZigzagDamage + anti-monotonicity consolidation." },
    { id: "aks_tree_sorting", file: "AKS/TreeSorting.lean", line: 2657, status: "sorry", kind: "theorem", milestone: true,
      sig: "aks_tree_sorting : (∀ m, IsEpsilonHalver (halvers m) ε) → ε < 1/2 →\n  ∃ net, net.size ≤ 200·(d+1)·n·log₂ n ∧ ∀ v, Monotone (net.exec v)",
      desc: "Main theorem: halver family → O(n log n) sorting network. Uses recursiveNearsort with multi-level halvers.", difficulty: "months" }
  ],

  // Edges: [source, target] means "target depends on source" (arrow points from source to target)
  edges: [
    // RegularGraph foundations
    ["RegularGraph", "walkCLM"],
    ["RegularGraph", "meanCLM"],
    ["walkCLM", "spectralGap"],
    ["meanCLM", "spectralGap"],
    ["spectralGap", "spectralGap_nonneg"],
    ["spectralGap", "spectralGap_le_one"],
    ["walkCLM", "spectralGap_le_one"],
    ["meanCLM", "spectralGap_le_one"],

    // Mean projection properties
    ["meanCLM", "meanCLM_idempotent"],
    ["meanCLM", "meanCLM_isSelfAdjoint"],

    // Square
    ["RegularGraph", "RegularGraph.square"],
    ["spectralGap", "spectralGap_square"],
    ["RegularGraph.square", "spectralGap_square"],
    ["walkCLM", "spectralGap_square"],
    ["meanCLM", "spectralGap_square"],
    ["meanCLM_idempotent", "spectralGap_square"],
    ["meanCLM_isSelfAdjoint", "spectralGap_square"],

    // Complete graph
    ["RegularGraph", "completeGraph"],
    ["spectralGap", "spectralGap_complete"],
    ["completeGraph", "spectralGap_complete"],

    // Mixing lemma
    ["spectralGap", "expander_mixing_lemma"],
    ["walkCLM", "expander_mixing_lemma"],
    ["indicatorVec", "expander_mixing_lemma"],
    ["RegularGraph", "expander_mixing_lemma"],

    // Sorting network basics
    ["Comparator", "ComparatorNetwork"],
    ["ComparatorNetwork", "IsSortingNetwork"],
    ["ComparatorNetwork", "zero_one_principle"],
    ["IsSortingNetwork", "zero_one_principle"],

    // Halver theory
    ["ComparatorNetwork", "IsEpsilonHalver"],
    ["RegularGraph", "expander_gives_halver"],
    ["spectralGap", "expander_gives_halver"],
    ["IsEpsilonHalver", "expander_gives_halver"],
    ["expander_mixing_lemma", "expander_gives_halver"],
    ["IsEpsilonHalver", "epsHalverMerge"],
    ["ComparatorNetwork", "epsHalverMerge"],
    ["IsEpsilonSorted", "Monotone.bool_pattern"],
    // Edges to deleted nodes (wrongness, halver_composition, etc.) removed

    // Zig-zag operators
    ["RegularGraph", "RegularGraph.zigzag"],
    ["walkCLM", "withinClusterCLM"],
    ["RegularGraph", "stepPermCLM"],
    ["meanCLM", "clusterMeanCLM"],
    ["Fin.pair_lt", "withinClusterCLM"],
    ["Fin.pair_lt", "stepPermCLM"],
    ["Fin.pair_lt", "clusterMeanCLM"],
    ["withinClusterCLM", "zigzag_walkCLM_eq"],
    ["stepPermCLM", "zigzag_walkCLM_eq"],
    ["RegularGraph.zigzag", "zigzag_walkCLM_eq"],

    // Zig-zag spectral properties
    ["clusterMeanCLM", "clusterMeanCLM_idempotent"],
    ["clusterMeanCLM", "clusterMeanCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinClusterCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "withinClusterCLM_norm_le_one"],
    ["stepPermCLM", "stepPermCLM_sq_eq_one"],
    ["stepPermCLM", "stepPermCLM_isSelfAdjoint"],
    ["stepPermCLM", "stepPermCLM_comp_meanCLM"],
    ["meanCLM", "stepPermCLM_comp_meanCLM"],
    ["withinClusterCLM", "withinCluster_tilde_contraction"],
    ["clusterMeanCLM", "withinCluster_tilde_contraction"],
    ["spectralGap", "withinCluster_tilde_contraction"],
    ["stepPermCLM", "hat_block_norm"],
    ["clusterMeanCLM", "hat_block_norm"],
    ["meanCLM", "hat_block_norm"],
    ["spectralGap", "hat_block_norm"],
    ["meanCLM_eq_clusterMean_comp", "hat_block_norm"],
    ["clusterMean_comp_meanCLM", "hat_block_norm"],
    ["meanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "clusterMean_comp_meanCLM"],
    ["meanCLM", "clusterMean_comp_meanCLM"],

    // RVW bound
    ["rvwBound", "rvwBound_mono_left"],
    ["rvwBound", "rvwBound_mono_right"],
    ["rvwBound", "rvw_quadratic_ineq"],
    ["rvw_quadratic_ineq", "rvw_operator_norm_bound"],
    ["rayleigh_quotient_bound", "rvw_operator_norm_bound"],

    // Zig-zag assembly
    ["zigzag_walkCLM_eq", "zigzag_spectral_bound"],
    ["clusterMeanCLM_idempotent", "zigzag_spectral_bound"],
    ["clusterMeanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinClusterCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_comp_clusterMean", "zigzag_spectral_bound"],
    ["clusterMean_comp_withinCluster", "zigzag_spectral_bound"],
    ["withinClusterCLM_norm_le_one", "zigzag_spectral_bound"],
    ["stepPermCLM_sq_eq_one", "zigzag_spectral_bound"],
    ["stepPermCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["stepPermCLM_comp_meanCLM", "zigzag_spectral_bound"],
    ["meanCLM_idempotent", "zigzag_spectral_bound"],
    ["meanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_tilde_contraction", "zigzag_spectral_bound"],
    ["hat_block_norm", "zigzag_spectral_bound"],
    ["meanCLM_eq_clusterMean_comp", "zigzag_spectral_bound"],
    ["clusterMean_comp_meanCLM", "zigzag_spectral_bound"],
    ["rvw_operator_norm_bound", "zigzag_spectral_bound"],

    // Iterated construction
    ["RegularGraph.square", "zigzagFamily"],
    ["RegularGraph.zigzag", "zigzagFamily"],
    ["zigzag_spectral_bound", "zigzagFamily_gap"],
    ["spectralGap_square", "zigzagFamily_gap"],
    ["rvwBound_mono_left", "zigzagFamily_gap"],
    ["rvwBound_mono_right", "zigzagFamily_gap"],
    ["zigzagFamily", "zigzagFamily_gap"],
    ["zigzagFamily_gap", "explicit_expanders_exist_zigzag"],
    ["zigzagFamily", "explicit_expanders_exist_zigzag"],

    // Base expander
    ["RegularGraph", "baseExpander"],
    ["spectralGap", "baseExpander_gap"],
    ["baseExpander", "baseExpander_gap"],

    // AKSNetwork.lean — helper lemmas
    ["epsHalverMerge", "epsHalverMerge_exec_eq_iterate"],
    ["epsHalverMerge", "epsHalverMerge_size"],

    // Top-level parameterized theorem (AKSNetwork.lean)
    ["zero_one_principle", "zigzag_implies_aks_network"],
    ["aks_tree_sorting", "zigzag_implies_aks_network"],
    ["expander_gives_halver", "zigzag_implies_aks_network"],

    // TreeSorting — edges FROM main proof chain into TreeSorting
    ["IsEpsilonHalver", "halver_preserves_monotone"],
    ["IsEpsilonHalver", "nearsort_has_bounded_tree_damage"],
    ["Comparator", "comparator_displacement_bound"],

    // TreeSorting — internal edges
    ["TreeNode", "treeWrongness"],
    ["countOnes_le", "countOnes_split"],
    ["recursiveNearsort", "nearsort_has_bounded_tree_damage"],
    ["nearsort_has_bounded_tree_damage", "HasBoundedTreeDamage"],
    ["HasBoundedTreeDamage", "bounded_tree_damage_pair_gives_zigzag"],
    ["bounded_tree_damage_pair_gives_zigzag", "HasBoundedZigzagDamage"],

    // V2 tree-distance-based definitions
    ["TreeNode", "sectionNode"],
    ["sectionIndex", "sectionNode"],
    ["sectionNode", "positionTreeDist"],
    ["positionTreeDist", "elementsAtTreeDist"],
    ["elementsAtTreeDist", "HasBoundedTreeDamage"],
    ["elementsAtTreeDist", "treeWrongnessV2"],
    ["HasBoundedTreeDamage", "cherry_wrongness_after_nearsort_v2"],
    ["treeWrongnessV2", "cherry_wrongness_after_nearsort_v2"],
    ["HasBoundedTreeDamage", "zig_step_bounded_increase_v2"],
    ["treeWrongnessV2", "zig_step_bounded_increase_v2"],
    ["positionTreeDist", "positionTreeDist_succ_le"],
    ["positionTreeDist_succ_le", "register_reassignment_increases_wrongness_v2"],
    ["treeWrongnessV2", "register_reassignment_increases_wrongness_v2"],
    ["elementsAtTreeDist", "register_reassignment_increases_wrongness_v2"],
    ["elementsAtTreeDist", "HasBoundedZigzagDamage"],
    ["HasBoundedZigzagDamage", "zigzag_decreases_wrongness_v2"],
    ["treeWrongnessV2", "zigzag_decreases_wrongness_v2"],

    // aks_tree_sorting — depends on V2 chain
    ["register_reassignment_increases_wrongness_v2", "aks_tree_sorting"],
    ["zigzag_decreases_wrongness_v2", "aks_tree_sorting"],
    ["nearsort_has_bounded_tree_damage", "aks_tree_sorting"],
    ["bounded_tree_damage_pair_gives_zigzag", "aks_tree_sorting"],

    // Main.lean — iterated squaring and final assembly
    ["spectralGap_square", "spectralGap_squareIter"],
    ["squareIter", "spectralGap_squareIter"],
    ["explicit_expanders_exist_zigzag", "expander_family_small_gap"],
    ["squareIter", "expander_family_small_gap"],
    ["spectralGap_squareIter", "expander_family_small_gap"],
    ["exists_pow_two_pow_lt", "expander_family_small_gap"],
    ["expander_family_small_gap", "aks_sorting_networks_exist"],
    ["zigzag_implies_aks_network", "aks_sorting_networks_exist"],

    // WalkBound
    ["spectralGap", "spectralGap_le_of_walk_bound"],
    ["walkCLM", "spectralGap_le_of_walk_bound"],

    // SpectralMatrix
    ["RegularGraph", "spectralMatrix"],
    ["spectralMatrix", "spectralMatrix_isHermitian"],
    ["spectralMatrix", "spectralMatrix_posSemidef_implies_walk_bound"],
    ["walkCLM", "spectralMatrix_posSemidef_implies_walk_bound"],
    ["meanCLM", "spectralMatrix_posSemidef_implies_walk_bound"],

    // DiagDominant (standalone, no AKS imports)

    // CertificateBridge
    ["certMatrixReal", "certMatrix_posdiag"],
    ["certMatrixReal", "kRowDominant_implies_diagDominant"],
    ["kRowDominant_implies_diagDominant", "congruence_diagDominant"],
    ["checkColumnNormBound_perRow", "congruence_diagDominant"],
    ["certMatrix_posdiag", "checker_implies_spectralMatrix_psd"],
    ["congruence_diagDominant", "checker_implies_spectralMatrix_psd"],
    ["diagDominant_posSemidef", "checker_implies_spectralMatrix_psd"],
    ["spectralMatrix", "checker_implies_spectralMatrix_psd"],
    ["checker_implies_spectralMatrix_psd", "certificate_implies_walk_bound"],
    ["spectralMatrix_posSemidef_implies_walk_bound", "certificate_implies_walk_bound"],
    ["certificate_implies_walk_bound", "certificate_bridge"],
    ["spectralGap_le_of_walk_bound", "certificate_bridge"],
    ["sqrt_coeff_le_frac", "certificate_bridge"]
  ],

  // File groupings with display names
  groups: [
    { id: "AKS/Fin.lean", label: "Fin.lean", color: "#1a1e24" },
    { id: "AKS/RegularGraph.lean", label: "RegularGraph.lean", color: "#1a1e24" },
    { id: "AKS/Square.lean", label: "Square.lean", color: "#1a1e24" },
    { id: "AKS/CompleteGraph.lean", label: "CompleteGraph.lean", color: "#1a1e24" },
    { id: "AKS/Mixing.lean", label: "Mixing.lean", color: "#1a1e24" },
    { id: "AKS/ComparatorNetwork.lean", label: "ComparatorNetwork.lean", color: "#1a1e24" },
    { id: "AKS/AKSNetwork.lean", label: "AKSNetwork.lean", color: "#1a1e24" },
    { id: "AKS/Halver.lean", label: "Halver.lean", color: "#1a1e24" },
    { id: "AKS/ZigZagOperators.lean", label: "ZigZagOperators.lean", color: "#1a1e24" },
    { id: "AKS/ZigZagSpectral.lean", label: "ZigZagSpectral.lean", color: "#1a1e24" },
    { id: "AKS/RVWBound.lean", label: "RVWBound.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag.lean", label: "ZigZag.lean", color: "#1a1e24" },
    { id: "AKS/WalkBound.lean", label: "WalkBound.lean", color: "#1a1e24" },
    { id: "AKS/SpectralMatrix.lean", label: "SpectralMatrix.lean", color: "#1a1e24" },
    { id: "AKS/DiagDominant.lean", label: "DiagDominant.lean", color: "#1a1e24" },
    { id: "AKS/CertificateBridge.lean", label: "CertificateBridge.lean", color: "#1a1e24" },
    { id: "AKS/Random.lean", label: "Random.lean", color: "#1a1e24" },
    { id: "AKS/TreeSorting.lean", label: "TreeSorting.lean", color: "#1a1e24" },
    { id: "AKS/Main.lean", label: "Main.lean", color: "#1a1e24" }
  ]
};
// ═══════════════════════════════════════════════════════

const statusColor = {
  proved: "#3fb950",
  sorry: "#d29922",
  axiom: "#f85149",
  definition: "#58a6ff"
};

// Difficulty → radius mapping
function difficultyRadius(d) {
  if (!d) return 4;
  if (d === "days") return 6;
  if (d === "1-2 weeks" || d === "weeks") return 8;
  if (d === "2-4 weeks") return 10;
  if (d === "months") return 12;
  return 4;
}

let W = window.innerWidth;
let H = window.innerHeight;

// Compute stats
const proved = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
const sorry = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
const axiomCount = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
const defs = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
document.getElementById("stats").innerHTML =
  `<div class="num" style="color:#3fb950">${proved}</div> proved<br>` +
  `<div class="num" style="color:#d29922">${sorry}</div> sorry<br>` +
  `<div class="num" style="color:#f85149">${axiomCount}</div> axiom<br>` +
  `<div class="num" style="color:#58a6ff">${defs}</div> definitions`;

// ── Compute DAG depth (longest path from roots) ──
const nodeMap = new Map(PROOF_DATA.nodes.map(n => [n.id, n]));
const inEdges = new Map();
const outEdges = new Map();
PROOF_DATA.nodes.forEach(n => { inEdges.set(n.id, []); outEdges.set(n.id, []); });
PROOF_DATA.edges.forEach(([s, t]) => {
  if (inEdges.has(t) && outEdges.has(s)) {
    inEdges.get(t).push(s);
    outEdges.get(s).push(t);
  }
});

const depth = new Map();
function getDepth(id) {
  if (depth.has(id)) return depth.get(id);
  depth.set(id, -1);
  const parents = inEdges.get(id) || [];
  const d = parents.length === 0 ? 0 : 1 + Math.max(...parents.map(getDepth));
  depth.set(id, d);
  return d;
}
PROOF_DATA.nodes.forEach(n => getDepth(n.id));
const maxDepth = Math.max(...PROOF_DATA.nodes.map(n => depth.get(n.id)));

// ── Assign radius and initial positions ──
PROOF_DATA.nodes.forEach(n => {
  n.depth = depth.get(n.id);
  n.radius = difficultyRadius(n.difficulty);
});

// Group nodes by file for group rectangles
const fileGroups = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!fileGroups.has(n.file)) fileGroups.set(n.file, []);
  fileGroups.get(n.file).push(n);
});

// Layout: Y is INVERTED (big theorems at top, foundations at bottom)
const LAYER_H = 75;
const TOP_PAD = 60;
const GRAPH_W = 1000;
const CENTER_X = GRAPH_W / 2;

// Seed initial positions: Y by inverted depth, X spread with noise
const layers = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!layers.has(n.depth)) layers.set(n.depth, []);
  layers.get(n.depth).push(n);
});
layers.forEach((nodesInLayer, d) => {
  const count = nodesInLayer.length;
  const layerW = Math.min(GRAPH_W, count * 80);
  nodesInLayer.forEach((n, i) => {
    // Inverted: max depth at top
    n.y = TOP_PAD + (maxDepth - d) * LAYER_H;
    n.x = CENTER_X - layerW/2 + (i + 0.5) * (layerW / count);
  });
});

// ── D3 setup ──
const svg = d3.select("#graph");
const g = svg.append("g");

// Arrow markers (green for clean edges, orange for edges with sorry/axiom below)
const defs2 = svg.append("defs");
[["arrow-green", "#3fb950"], ["arrow-orange", "#d29922"]].forEach(([id, color]) => {
  defs2.append("marker")
    .attr("id", id)
    .attr("viewBox", "0 0 10 6")
    .attr("refX", 10)
    .attr("refY", 3)
    .attr("markerWidth", 8)
    .attr("markerHeight", 5)
    .attr("orient", "auto")
    .append("polygon")
    .attr("points", "0,0 10,3 0,6")
    .attr("fill", color);
});

// Zoom
const zoom = d3.zoom()
  .scaleExtent([0.15, 4])
  .on("zoom", (e) => g.attr("transform", e.transform));
svg.call(zoom);

function resetZoom(instant) {
  const graphH = TOP_PAD + (maxDepth + 1) * LAYER_H + 40;
  const scaleX = W / (GRAPH_W + 80);
  const scaleY = (H - 20) / graphH;
  let s = Math.min(scaleX, scaleY, 1.1) * 0.9;
  // On mobile the fit-all scale makes nodes sub-pixel; enforce a minimum
  // so nodes are visible and let the user pan to explore.
  if (W <= 600) s = Math.max(s, 0.7);
  const tx = (W - GRAPH_W * s) / 2;
  const ty = W <= 600 ? -graphH * s * 0.15 : 10;
  const t = d3.zoomIdentity.translate(tx, ty).scale(s);
  if (instant) {
    svg.call(zoom.transform, t);
  } else {
    svg.transition().duration(500).call(zoom.transform, t);
  }
}

let labelsVisible = true;
function toggleLabels() {
  labelsVisible = !labelsVisible;
  g.selectAll(".node-label").attr("opacity", labelsVisible ? 1 : 0);
}

// ── Build links ──
const links = PROOF_DATA.edges
  .filter(([s, t]) => nodeMap.has(s) && nodeMap.has(t))
  .map(([s, t]) => ({ source: nodeMap.get(s), target: nodeMap.get(t) }));

// ── Edge color computation ──
// For each node, compute whether it and all its transitive dependencies are
// "clean" (proved or definition).  Edge color = green if source is clean,
// orange if any dependency below is sorry/axiom.
const depsMap = new Map();
PROOF_DATA.nodes.forEach(n => depsMap.set(n.id, []));
links.forEach(l => {
  const arr = depsMap.get(l.target.id);
  if (arr) arr.push(l.source.id);
});

let edgeCleanMap;
function computeEdgeColors(getStatus) {
  const clean = new Map();
  function check(id) {
    if (clean.has(id)) return clean.get(id);
    clean.set(id, true); // cycle guard
    const st = getStatus(id);
    if (st !== "proved" && st !== "definition") { clean.set(id, false); return false; }
    for (const dep of (depsMap.get(id) || [])) {
      if (!check(dep)) { clean.set(id, false); return false; }
    }
    return true;
  }
  PROOF_DATA.nodes.forEach(n => check(n.id));
  edgeCleanMap = clean;
}
function edgeStroke(l) { return edgeCleanMap.get(l.source.id) ? "#3fb950" : "#d29922"; }
function edgeMarker(l) { return edgeCleanMap.get(l.source.id) ? "url(#arrow-green)" : "url(#arrow-orange)"; }

// Initial computation from live statuses
computeEdgeColors(id => nodeMap.get(id)?.status || "sorry");

// ── Force simulation for organic layout ──
// Strong Y force keeps depth ordering; charge + collision spread nodes apart
const simulation = d3.forceSimulation(PROOF_DATA.nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(50).strength(0.15))
  .force("charge", d3.forceManyBody().strength(-120))
  .force("y", d3.forceY().y(d => TOP_PAD + (maxDepth - d.depth) * LAYER_H).strength(0.85))
  .force("x", d3.forceX(CENTER_X).strength(0.03))
  .force("collision", d3.forceCollide().radius(d => d.radius + 14))
  .alphaDecay(0.025)
  .alpha(0.8);

// Save layout positions after simulation settles
let simulationDone = false;
const groupCentroids = new Map();
let currentSnapshotIndex = null; // null = live mode

simulation.on("end", () => {
  PROOF_DATA.nodes.forEach(d => { d.liveX = d.x; d.liveY = d.y; });
  fileGroups.forEach((nodes, fileId) => {
    groupCentroids.set(fileId, {
      x: nodes.reduce((s, n) => s + n.liveX, 0) / nodes.length,
      y: nodes.reduce((s, n) => s + n.liveY, 0) / nodes.length,
    });
  });
  simulationDone = true;
  // Re-fit after simulation settles (positions are now final)
  resetZoom(false);
});

function isNodeVisible(id) {
  if (currentSnapshotIndex === null || !HISTORY_DATA) return true;
  if (currentSnapshotIndex >= HISTORY_DATA.snapshots.length) return true;
  return !!HISTORY_DATA.snapshots[currentSnapshotIndex].nodes[id];
}

// ── Draw group rects (updated on tick) ──
const groupRects = g.append("g").selectAll("rect")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("rect")
  .attr("class", "group-rect")
  .attr("fill", d => d.color)
  .attr("stroke", "#21262d")
  .attr("stroke-width", 1);

const groupLabels = g.append("g").selectAll("text")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("text")
  .attr("class", "group-label")
  .text(d => d.label);

// ── Draw edges ──
const linkSel = g.append("g")
  .selectAll("path")
  .data(links)
  .join("path")
  .attr("class", "link")
  .attr("stroke", edgeStroke)
  .attr("stroke-width", 1.2)
  .attr("opacity", 0.35)
  .attr("marker-end", edgeMarker);

// ── Draw nodes ──
const nodeSel = g.append("g")
  .selectAll("circle")
  .data(PROOF_DATA.nodes)
  .join("circle")
  .attr("class", "node-circle")
  .attr("r", d => d.radius)
  .attr("fill", d => statusColor[d.status])
  .attr("stroke", d => d3.color(statusColor[d.status]).darker(0.5).formatHex())
  .call(d3.drag()
    .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.15).restart(); d.fx = d.x; d.fy = d.y; })
    .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
    .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
  );

// ── Node labels ──
const labelSel = g.append("g")
  .selectAll("text")
  .data(PROOF_DATA.nodes)
  .join("text")
  .attr("class", "node-label")
  .text(d => {
    let name = d.id;
    name = name.replace("RegularGraph.", "").replace("CLM", "");
    if (name.length > 22) name = name.substring(0, 20) + "..";
    return name;
  });

// ── Edge path helper ──
function edgePath(d) {
  const sx = d.source.x, sy = d.source.y;
  const tx = d.target.x, ty = d.target.y;
  const dx = tx - sx, dy = ty - sy;
  const len = Math.sqrt(dx*dx + dy*dy) || 1;
  // Shorten at both ends by node radii
  const sr = d.source.radius + 2;
  const tr = d.target.radius + 5; // extra for arrowhead
  const bx = sx + (dx/len)*sr, by = sy + (dy/len)*sr;
  const ex = tx - (dx/len)*tr, ey = ty - (dy/len)*tr;
  // Gentle curve
  const mx = (bx + ex) / 2, my = (by + ey) / 2;
  const offset = (ex - bx) * 0.12;
  return `M${bx},${by} Q${mx + offset},${my} ${ex},${ey}`;
}

// ── Tick ──
simulation.on("tick", () => {
  linkSel.attr("d", edgePath);

  nodeSel.attr("cx", d => d.x).attr("cy", d => d.y);

  labelSel
    .attr("x", d => d.x)
    .attr("y", d => d.y + d.radius + 12);

  // Update group rectangles
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    const xs = nodes.map(n => n.x), ys = nodes.map(n => n.y);
    d3.select(this)
      .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
      .attr("width", Math.max(...xs) - Math.min(...xs) + 2*pad)
      .attr("height", Math.max(...ys) - Math.min(...ys) + 2*pad);
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    d3.select(this)
      .attr("x", Math.min(...nodes.map(n => n.x)) - pad + 6)
      .attr("y", Math.min(...nodes.map(n => n.y)) - pad + 13);
  });
});

// ── Tooltip ──
const tooltip = document.getElementById("tooltip");

nodeSel.on("mouseover", (e, d) => {
  tooltip.style.display = "block";
  let html = `<div class="tt-name">${d.id}</div>`;
  html += `<div class="tt-file">${d.file}:${d.line} &mdash; <span style="color:${statusColor[d.status]}">${d.status}</span></div>`;
  html += `<div class="tt-sig">${escHtml(d.sig)}</div>`;
  html += `<div class="tt-desc">${d.desc}</div>`;
  if (d.difficulty) html += `<div class="tt-diff">Estimated difficulty: ${d.difficulty}</div>`;
  tooltip.innerHTML = html;
})
.on("mousemove", (e) => {
  let x = e.clientX + 16, y = e.clientY + 16;
  if (x + 480 > W) x = e.clientX - 496;
  if (y + 200 > H) y = e.clientY - 200;
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
})
.on("mouseout", () => { tooltip.style.display = "none"; })
.on("click", (e, d) => {
  window.open(`${PROOF_DATA.repo}/blob/main/${d.file}#L${d.line}`, "_blank");
});

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Highlight connected nodes on hover ──
nodeSel.on("mouseover.highlight", (e, d) => {
  const connected = new Set([d.id]);
  links.forEach(l => {
    if (l.source.id === d.id) connected.add(l.target.id);
    if (l.target.id === d.id) connected.add(l.source.id);
  });
  nodeSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return connected.has(n.id) ? 1 : 0.15;
  });
  labelSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return (connected.has(n.id) && labelsVisible) ? 1 : 0.05;
  });
  linkSel.attr("opacity", l => {
    if (!isNodeVisible(l.source.id) || !isNodeVisible(l.target.id)) return 0;
    return (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.04;
  });
}).on("mouseout.highlight", () => {
  // Restore timeline state
  const slider = document.getElementById('timeSlider');
  if (HISTORY_DATA && slider && parseInt(slider.value) < HISTORY_DATA.snapshots.length) {
    applySnapshot(parseInt(slider.value), false);
  } else {
    nodeSel.attr("opacity", 1);
    labelSel.attr("opacity", labelsVisible ? 1 : 0);
    linkSel.attr("opacity", 0.35).attr("stroke", edgeStroke).attr("marker-end", edgeMarker);
  }
});

// ── Initial zoom to fit (instant, no transition) ──
setTimeout(() => resetZoom(true), 100);

// ═══════════════════════════════════════════════════════
// TIMELINE ANIMATION — loads history.json, scrubs through proof history
// ═══════════════════════════════════════════════════════
let HISTORY_DATA = null;
let playing = false;
let playInterval = null;
let playSpeed = 200;

fetch('history.json')
  .then(r => { if (!r.ok) throw new Error('No history'); return r.json(); })
  .then(data => { HISTORY_DATA = data; initTimeline(); })
  .catch(() => { /* No history.json — static mode only */ });

function initTimeline() {
  if (!HISTORY_DATA || !HISTORY_DATA.snapshots.length) return;
  const slider = document.getElementById('timeSlider');
  slider.max = HISTORY_DATA.snapshots.length; // 0..N-1 = snapshots, N = live
  slider.value = slider.max;
  document.getElementById('timeline').style.display = 'flex';
  updateDateDisplay(parseInt(slider.max));
}

function applySnapshot(index, animated) {
  const dur = animated ? 120 : 0;
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const snapshot = isLive ? null : HISTORY_DATA.snapshots[index];
  currentSnapshotIndex = isLive ? null : index;

  // Build visibility map
  const vis = new Map();
  PROOF_DATA.nodes.forEach(d => {
    vis.set(d.id, isLive || !!snapshot.nodes[d.id]);
  });

  // Move node positions: visible → layout position, hidden → group centroid
  if (simulationDone) {
    PROOF_DATA.nodes.forEach(d => {
      if (vis.get(d.id)) {
        d.x = d.liveX;
        d.y = d.liveY;
      } else {
        const c = groupCentroids.get(d.file);
        if (c) { d.x = c.x; d.y = c.y; }
      }
    });
  }

  // Helper: optionally wrap selection in a transition.
  // When instant (dur=0), interrupt any in-progress transitions to prevent flickering.
  function tw(sel) {
    if (dur > 0) return sel.transition().duration(dur);
    sel.interrupt();
    return sel;
  }

  // Nodes: position, color, size, opacity
  tw(nodeSel)
    .attr("cx", d => d.x).attr("cy", d => d.y)
    .attr("r", d => vis.get(d.id) ? d.radius : 0)
    .attr("fill", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return statusColor[st] || statusColor[d.status];
    })
    .attr("stroke", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return d3.color(statusColor[st] || statusColor[d.status]).darker(0.5).formatHex();
    })
    .attr("opacity", d => vis.get(d.id) ? 1 : 0);

  // Labels: position and opacity
  tw(labelSel)
    .attr("x", d => d.x).attr("y", d => d.y + d.radius + 12)
    .attr("opacity", d => (vis.get(d.id) && labelsVisible) ? 1 : 0);

  // Recompute edge colors for this snapshot's statuses
  computeEdgeColors(id => {
    const st = isLive ? nodeMap.get(id)?.status : (snapshot.nodes[id] || null);
    return st || nodeMap.get(id)?.status || "sorry";
  });

  // Edges: path, color, opacity
  tw(linkSel)
    .attr("d", edgePath)
    .attr("stroke", edgeStroke)
    .attr("marker-end", edgeMarker)
    .attr("opacity", l => {
      return (isLive || (vis.get(l.source.id) && vis.get(l.target.id))) ? 0.35 : 0;
    });

  // Group rects: recompute bounds from visible nodes only
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      const xs = vn.map(n => n.x), ys = vn.map(n => n.y);
      el.attr("opacity", 1)
        .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
        .attr("width", Math.max(...xs) - Math.min(...xs) + 2 * pad)
        .attr("height", Math.max(...ys) - Math.min(...ys) + 2 * pad);
    }
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      el.attr("opacity", 1)
        .attr("x", Math.min(...vn.map(n => n.x)) - pad + 6)
        .attr("y", Math.min(...vn.map(n => n.y)) - pad + 13);
    }
  });

  // Stats and date display
  updateTimelineStats(isLive, snapshot);
  updateDateDisplay(index);
}

function updateTimelineStats(isLive, snapshot) {
  let p, s, a, df;
  if (isLive) {
    p = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
    s = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
    a = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
    df = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
  } else {
    const vals = Object.values(snapshot.nodes);
    p = vals.filter(v => v === "proved").length;
    s = vals.filter(v => v === "sorry").length;
    a = vals.filter(v => v === "axiom").length;
    df = vals.filter(v => v === "definition").length;
  }
  document.getElementById("stats").innerHTML =
    `<div class="num" style="color:#3fb950">${p}</div> proved<br>` +
    `<div class="num" style="color:#d29922">${s}</div> sorry<br>` +
    `<div class="num" style="color:#f85149">${a}</div> axiom<br>` +
    `<div class="num" style="color:#58a6ff">${df}</div> definitions`;
}

function updateDateDisplay(index) {
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const dateEl = document.getElementById('timeDate');
  const liveEl = document.getElementById('liveBadge');
  if (isLive) {
    dateEl.textContent = 'Current';
    liveEl.style.visibility = 'visible';
  } else {
    const s = HISTORY_DATA.snapshots[index];
    const d = new Date(s.date);
    const ds = d.toLocaleDateString('en-GB', {year:'numeric', month:'short', day:'numeric'});
    const msg = s.message.length > 50 ? s.message.substring(0, 47) + '...' : s.message;
    dateEl.textContent = `${ds} \u2014 ${msg}`;
    liveEl.style.visibility = 'hidden';
  }
}

function scrubTo(value) {
  applySnapshot(parseInt(value), false);
}

function advanceFrame() {
  const slider = document.getElementById('timeSlider');
  const next = parseInt(slider.value) + 1;
  if (next > parseInt(slider.max)) {
    togglePlay();
    return;
  }
  slider.value = next;
  applySnapshot(next, true);
}

function startPlaying() {
  clearInterval(playInterval);
  playInterval = setInterval(advanceFrame, playSpeed);
}

function togglePlay() {
  playing = !playing;
  document.getElementById('playBtn').innerHTML = playing ? '&#9646;&#9646;' : '&#9654;';
  if (playing) {
    const slider = document.getElementById('timeSlider');
    if (parseInt(slider.value) >= parseInt(slider.max)) {
      slider.value = 0;
      applySnapshot(0, false);
    }
    startPlaying();
  } else {
    clearInterval(playInterval);
  }
}

function updateSpeed() {
  playSpeed = parseInt(document.getElementById('speedSelect').value);
  if (playing) startPlaying();
}

// ═══════════════════════════════════════════════════════
// MOBILE / RESPONSIVE SUPPORT
// ═══════════════════════════════════════════════════════

// Resize handler — recompute dimensions and re-fit
window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  resetZoom();
});

// Legend toggle for mobile
function toggleLegend() {
  document.getElementById('legend').classList.toggle('open');
}

// Close legend when tapping elsewhere on mobile
document.addEventListener('click', (e) => {
  const legend = document.getElementById('legend');
  const toggle = document.getElementById('legend-toggle');
  if (!legend.contains(e.target) && e.target !== toggle) {
    legend.classList.remove('open');
  }
});

// Touch support for tooltips (tap node = show tooltip, tap elsewhere = dismiss)
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let activeTooltipNode = null;

if (isTouchDevice) {
  // Prevent default touch-drag on nodes so tooltip shows on tap
  nodeSel.on('touchstart', function(e, d) {
    // Single-finger tap: show tooltip
    if (e.touches.length === 1) {
      e.preventDefault();
      e.stopPropagation();

      if (activeTooltipNode === d) {
        // Second tap on same node: open link
        window.open(`${PROOF_DATA.repo}/blob/main/${d.file}#L${d.line}`, '_blank');
        dismissTooltip();
        return;
      }

      activeTooltipNode = d;

      // Show tooltip content
      let html = `<div class="tt-name">${d.id}</div>`;
      html += `<div class="tt-file">${d.file}:${d.line} &mdash; <span style="color:${statusColor[d.status]}">${d.status}</span></div>`;
      html += `<div class="tt-sig">${escHtml(d.sig)}</div>`;
      html += `<div class="tt-desc">${d.desc}</div>`;
      if (d.difficulty) html += `<div class="tt-diff">Estimated difficulty: ${d.difficulty}</div>`;
      html += `<div style="margin-top:8px;font-size:10px;color:#484f58;">Tap again to open on GitHub</div>`;
      tooltip.innerHTML = html;
      tooltip.style.display = 'block';

      // Position: on mobile, anchor to bottom of viewport; on desktop, near touch point
      if (W <= 600) {
        tooltip.style.left = '16px';
        tooltip.style.top = '';
        tooltip.style.bottom = '8px';
      } else {
        const touch = e.touches[0];
        let x = touch.clientX + 16, y = touch.clientY + 16;
        if (x + 480 > W) x = touch.clientX - 496;
        if (y + 200 > H) y = touch.clientY - 200;
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
        tooltip.style.bottom = '';
      }

      // Highlight connected
      const connected = new Set([d.id]);
      links.forEach(l => {
        if (l.source.id === d.id) connected.add(l.target.id);
        if (l.target.id === d.id) connected.add(l.source.id);
      });
      nodeSel.attr('opacity', n => {
        if (!isNodeVisible(n.id)) return 0;
        return connected.has(n.id) ? 1 : 0.15;
      });
      labelSel.attr('opacity', n => {
        if (!isNodeVisible(n.id)) return 0;
        return (connected.has(n.id) && labelsVisible) ? 1 : 0.05;
      });
      linkSel.attr('opacity', l => {
        if (!isNodeVisible(l.source.id) || !isNodeVisible(l.target.id)) return 0;
        return (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.04;
      });
    }
  });

  // Tap on background dismisses tooltip
  svg.on('touchstart.dismiss', (e) => {
    if (e.target.tagName === 'svg' || e.target.classList.contains('group-rect')) {
      dismissTooltip();
    }
  });

  // Also dismiss on tap outside the tooltip itself
  document.addEventListener('touchstart', (e) => {
    if (activeTooltipNode && !tooltip.contains(e.target) &&
        !e.target.classList.contains('node-circle')) {
      dismissTooltip();
    }
  });
}

function dismissTooltip() {
  activeTooltipNode = null;
  tooltip.style.display = 'none';
  tooltip.style.bottom = '';
  // Restore normal opacity
  const slider = document.getElementById('timeSlider');
  if (HISTORY_DATA && slider && parseInt(slider.value) < HISTORY_DATA.snapshots.length) {
    applySnapshot(parseInt(slider.value), false);
  } else {
    nodeSel.attr('opacity', d => isNodeVisible(d.id) ? 1 : 0);
    labelSel.attr('opacity', d => (isNodeVisible(d.id) && labelsVisible) ? 1 : 0);
    linkSel.attr('opacity', 0.35).attr('stroke', edgeStroke).attr('marker-end', edgeMarker);
  }
}

// Mark body when timeline is active (for CSS adjustments)
const timelineObserver = new MutationObserver(() => {
  const tl = document.getElementById('timeline');
  document.body.classList.toggle('has-timeline', tl.style.display === 'flex');
});
timelineObserver.observe(document.getElementById('timeline'), { attributes: true, attributeFilter: ['style'] });
</script>
</body>
</html>
