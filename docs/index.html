<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AKS dependencies</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0d1117; color: #c9d1d9; overflow: hidden; }
#controls { position: fixed; top: 12px; left: 12px; z-index: 10; display: flex; gap: 8px; align-items: center; }
#controls button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
#controls button:hover { background: #30363d; }
#title { position: fixed; top: 12px; right: 16px; z-index: 10; text-align: right; }
#title h1 { font-size: 18px; font-weight: 600; color: #e6edf3; }
#title p { font-size: 12px; color: #7d8590; margin-top: 2px; }
#legend { position: fixed; bottom: 16px; left: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; line-height: 1.5; }
#legend .section { margin-bottom: 8px; }
#legend .section:last-child { margin-bottom: 0; }
#legend .section-title { color: #484f58; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }
#legend .item { display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
#legend .dot { border-radius: 50%; flex-shrink: 0; }
#legend .size-dot { background: #484f58; }
#legend-toggle { display: none; }
#stats { position: fixed; bottom: 16px; right: 16px; z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px 16px; font-size: 12px; text-align: right; }
#stats .num { font-size: 20px; font-weight: 700; }
#tooltip { position: fixed; pointer-events: none; background: #1c2128; border: 1px solid #444c56; border-radius: 8px; padding: 12px 16px; font-size: 13px; max-width: 480px; z-index: 100; display: none; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
#tooltip .tt-name { font-weight: 700; font-size: 15px; color: #e6edf3; margin-bottom: 4px; }
#tooltip .tt-file { font-size: 11px; color: #7d8590; margin-bottom: 6px; }
#tooltip .tt-sig { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 11px; color: #a5d6ff; background: #0d1117; padding: 6px 8px; border-radius: 4px; margin-bottom: 6px; white-space: pre-wrap; word-break: break-all; max-height: 120px; overflow-y: auto; }
#tooltip .tt-desc { color: #c9d1d9; line-height: 1.4; }
#tooltip .tt-diff { margin-top: 4px; font-size: 11px; color: #7d8590; font-style: italic; }
#graph { width: 100vw; height: 100vh; touch-action: none; }
.group-rect { rx: 12; ry: 12; }
.group-label { font-size: 11px; font-weight: 600; fill: #484f58; pointer-events: none; }
.link { fill: none; }
.node-circle { cursor: pointer; stroke-width: 1.5; }
.node-circle:hover { filter: brightness(1.3); }
.node-label { font-size: 10px; fill: #8b949e; pointer-events: none; text-anchor: middle; }
#timeline { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 10; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 8px 16px; display: none; align-items: center; gap: 10px; font-size: 12px; }
#timeline button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 14px; line-height: 1; }
#timeline button:hover { background: #30363d; }
#timeline select { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 3px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; }
#timeline input[type=range] { width: 300px; accent-color: #58a6ff; }
#timeDate { color: #7d8590; width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; }
#liveBadge { background: #3fb950; color: #0d1117; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; visibility: hidden; }

/* ── Mobile / narrow screens ── */
@media (max-width: 600px) {
  /* Row 1: buttons */
  #controls { top: 8px; left: 8px; gap: 4px; }
  #controls button { padding: 8px 10px; font-size: 12px; min-height: 36px; }

  /* Row 2: title below buttons, subtitle hidden */
  #title { top: 50px; left: 8px; right: auto; text-align: left; }
  #title h1 { font-size: 14px; }
  #title p { display: none; }

  /* Legend: collapse behind a toggle button, below title */
  #legend { display: none; bottom: auto; top: 76px; left: 8px; padding: 10px 12px; font-size: 11px; }
  #legend.open { display: block; }
  #legend-toggle { display: block; }

  /* Stats: compact at bottom-right */
  #stats { bottom: 8px; right: 8px; padding: 8px 10px; font-size: 11px; }
  #stats .num { font-size: 16px; }

  /* Tooltip: fit within viewport */
  #tooltip { max-width: calc(100vw - 32px); left: 16px !important; right: 16px; font-size: 12px; padding: 10px 12px; pointer-events: auto; }
  #tooltip .tt-name { font-size: 14px; }
  #tooltip .tt-sig { font-size: 10px; max-height: 80px; }

  /* Timeline: full width */
  #timeline { left: 8px; right: 8px; transform: none; bottom: 8px; padding: 6px 10px; gap: 6px; flex-wrap: wrap; justify-content: center; }
  #timeline input[type=range] { width: 100%; order: 10; }
  #timeDate { width: auto; max-width: 50vw; font-size: 10px; }

  /* When timeline is visible, push stats above it */
  body.has-timeline #stats { bottom: 72px; }
}
</style>
</head>
<body>

<div id="controls">
  <button onclick="resetZoom()">Reset View</button>
  <button onclick="toggleLabels()">Toggle Labels</button>
  <button id="legend-toggle" onclick="toggleLegend()">Legend</button>
</div>

<div id="title">
  <h1>AKS Sorting Network</h1>
  <p>Lean Proof Dependency Graph</p>
</div>

<div id="legend">
  <div class="section">
    <div class="section-title">Status</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#3fb950;"></div> Proved</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#d29922;"></div> Sorry</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#f85149;"></div> Axiom</div>
    <div class="item"><div class="dot" style="width:12px;height:12px;background:#58a6ff;"></div> Definition</div>
  </div>
  <div class="section">
    <div class="section-title">Est. duration</div>
    <div class="item"><div class="dot size-dot" style="width:8px;height:8px;"></div> done / n/a</div>
    <div class="item"><div class="dot size-dot" style="width:12px;height:12px;"></div> days</div>
    <div class="item"><div class="dot size-dot" style="width:16px;height:16px;"></div> weeks</div>
    <div class="item"><div class="dot size-dot" style="width:22px;height:22px;"></div> months</div>
  </div>
  <div class="section">
    <div class="section-title">Edges</div>
    <div class="item">
      <svg width="32" height="12"><line x1="0" y1="6" x2="24" y2="6" stroke="#3fb950" stroke-width="1.5"/><polygon points="24,3 30,6 24,9" fill="#3fb950"/></svg>
      all proved below
    </div>
    <div class="item">
      <svg width="32" height="12"><line x1="0" y1="6" x2="24" y2="6" stroke="#d29922" stroke-width="1.5"/><polygon points="24,3 30,6 24,9" fill="#d29922"/></svg>
      sorry/axiom below
    </div>
  </div>
</div>

<div id="stats"></div>
<div id="tooltip"></div>

<div id="timeline">
  <button id="playBtn" onclick="togglePlay()">&#9654;</button>
  <select id="speedSelect" onchange="updateSpeed()">
    <option value="500">1&times;</option>
    <option value="200" selected>2&times;</option>
    <option value="100">5&times;</option>
  </select>
  <input type="range" id="timeSlider" min="0" max="0" value="0" oninput="scrubTo(this.value)">
  <span id="timeDate">Current</span>
  <span id="liveBadge">LIVE</span>
</div>

<svg id="graph"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════
// PROOF_DATA — update this block to refresh the visualization
// ═══════════════════════════════════════════════════════
const PROOF_DATA = {
  repo: "https://github.com/girving/aks",
  nodes: [
    // ── Misc/Fin.lean ──
    { id: "Fin.pair_lt", file: "AKS/Misc/Fin.lean", line: 15, status: "proved", kind: "theorem",
      sig: "Fin.pair_lt : j.val * d + i.val < n * d",
      desc: "Product encoding bound for Fin n x Fin d." },
    { id: "rank_fin_val", file: "AKS/Misc/Fin.lean", line: 66, status: "proved", kind: "lemma",
      sig: "rank_fin_val {n : ℕ} (i : Fin n) : rank i = i.val",
      desc: "The rank of a Fin n element equals its value. Unfolds rank and uses Fin.card_Iio." },

    // ── Graph/Regular.lean ──
    { id: "RegularGraph", file: "AKS/Graph/Regular.lean", line: 35, status: "definition", kind: "structure",
      sig: "structure RegularGraph (n d : ℕ) where\n  rot : Fin n × Fin d → Fin n × Fin d\n  rot_involution : ...",
      desc: "D-regular graph on n vertices, represented by an involutory rotation map on vertex-port pairs." },
    { id: "walkCLM", file: "AKS/Graph/Regular.lean", line: 130, status: "definition", kind: "def",
      sig: "RegularGraph.walkCLM : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Walk operator as a continuous linear map: averages a function over neighbors." },
    { id: "meanCLM", file: "AKS/Graph/Regular.lean", line: 163, status: "definition", kind: "def",
      sig: "meanCLM (n : ℕ) : EuclideanSpace ℝ (Fin n) →L[ℝ] EuclideanSpace ℝ (Fin n)",
      desc: "Mean projection CLM: projects onto the constant-function subspace." },
    { id: "meanCLM_idempotent", file: "AKS/Graph/Regular.lean", line: 173, status: "proved", kind: "theorem",
      sig: "meanCLM_idempotent : meanCLM n * meanCLM n = meanCLM n",
      desc: "Mean projection is idempotent (P² = P)." },
    { id: "meanCLM_isSelfAdjoint", file: "AKS/Graph/Regular.lean", line: 184, status: "proved", kind: "theorem",
      sig: "meanCLM_isSelfAdjoint : IsSelfAdjoint (meanCLM n)",
      desc: "Mean projection is self-adjoint." },
    { id: "spectralGap", file: "AKS/Graph/Regular.lean", line: 263, status: "definition", kind: "def",
      sig: "spectralGap (G : RegularGraph n d) : ℝ := ‖G.walkCLM - meanCLM n‖",
      desc: "Spectral gap: operator norm of walk minus mean projection." },
    { id: "spectralGap_nonneg", file: "AKS/Graph/Regular.lean", line: 267, status: "proved", kind: "theorem",
      sig: "spectralGap_nonneg : 0 ≤ spectralGap G",
      desc: "Spectral gap is non-negative (norm is non-negative)." },
    { id: "spectralGap_le_one", file: "AKS/Graph/Regular.lean", line: 330, status: "proved", kind: "theorem",
      sig: "spectralGap_le_one : spectralGap G ≤ 1",
      desc: "Spectral gap is at most 1. Proved via walk contraction and WP = P factoring." },

    // ── Graph/Square.lean ──
    { id: "RegularGraph.square", file: "AKS/Graph/Square.lean", line: 39, status: "definition", kind: "def",
      sig: "RegularGraph.square : RegularGraph n (d * d)",
      desc: "Squared graph: two-step walks become single edges. Degree goes from d to d*d." },
    { id: "spectralGap_square", file: "AKS/Graph/Square.lean", line: 182, status: "proved", kind: "theorem",
      sig: "spectralGap_square : spectralGap G.square = (spectralGap G) ^ 2",
      desc: "Squaring a graph squares its spectral gap. Key CLM identity: (W-P)^2 = W^2 - P." },

    // ── Graph/Complete.lean ──
    { id: "completeGraph", file: "AKS/Graph/Complete.lean", line: 30, status: "definition", kind: "def",
      sig: "completeGraph (n : ℕ) : RegularGraph (n + 1) n",
      desc: "Complete graph K_{n+1} as an n-regular graph, using Fin.succAbove/predAbove." },
    { id: "spectralGap_complete", file: "AKS/Graph/Complete.lean", line: 112, status: "proved", kind: "theorem",
      sig: "spectralGap_complete : spectralGap (completeGraph n) = 1 / n",
      desc: "The complete graph K_{n+1} has spectral gap exactly 1/n." },

    // ── Mixing.lean ──
    { id: "indicatorVec", file: "AKS/Halver/Mixing.lean", line: 24, status: "definition", kind: "def",
      sig: "indicatorVec (S : Finset (Fin n)) : EuclideanSpace ℝ (Fin n)",
      desc: "Indicator vector: 1 on vertices in S, 0 elsewhere." },
    { id: "expander_mixing_lemma", file: "AKS/Halver/Mixing.lean", line: 120, status: "proved", kind: "theorem",
      sig: "expander_mixing_lemma : |edges(S,T)/d - |S||T|/n| ≤ λ · √(|S|·|T|)",
      desc: "Expander mixing lemma: edge distribution between sets S,T is close to uniform, controlled by spectral gap." },

    // ── Sort/ — Sorting Networks ──
    { id: "Comparator", file: "AKS/Sort/Defs.lean", line: 22, status: "definition", kind: "structure",
      sig: "structure Comparator (n : ℕ) where\n  i : Fin n\n  j : Fin n",
      desc: "A comparator: swaps elements at positions i and j if out of order." },
    { id: "ComparatorNetwork", file: "AKS/Sort/Defs.lean", line: 36, status: "definition", kind: "structure",
      sig: "structure ComparatorNetwork (n : ℕ) where\n  comparators : List (Comparator n)",
      desc: "A comparator network: a sequence of comparators applied in order." },
    { id: "IsSortingNetwork", file: "AKS/Sort/Monotone.lean", line: 146, status: "definition", kind: "def",
      sig: "IsSortingNetwork (net : ComparatorNetwork n) : Prop",
      desc: "Predicate: the network sorts every input." },
    { id: "zero_one_principle", file: "AKS/Sort/ZeroOne.lean", line: 16, status: "proved", kind: "theorem",
      sig: "zero_one_principle : (∀ v : Fin n → Bool, Monotone (net.exec v)) → IsSortingNetwork net",
      desc: "The 0-1 principle: if a comparator network sorts all Boolean inputs, it sorts everything." },
    { id: "Comparator.apply_injective", file: "AKS/Sort/Defs.lean", line: 71, status: "proved", kind: "theorem",
      sig: "Comparator.apply_injective (c : Comparator n) {v : Fin n → α} (hv : Function.Injective v) :\n  Function.Injective (c.apply v)",
      desc: "A single comparator preserves injectivity: either no swap (identity) or a transposition." },
    { id: "exec_injective", file: "AKS/Sort/Defs.lean", line: 97, status: "proved", kind: "theorem",
      sig: "ComparatorNetwork.exec_injective (net : ComparatorNetwork n) {v : Fin n → α}\n  (hv : Function.Injective v) : Function.Injective (net.exec v)",
      desc: "Executing a comparator network preserves injectivity. Induction on comparator list." },
    { id: "shiftEmbed_exec_outside", file: "AKS/Sort/Defs.lean", line: 164, status: "proved", kind: "theorem",
      sig: "ComparatorNetwork.shiftEmbed_exec_outside (net : ComparatorNetwork m)\n  (n offset : ℕ) (h : offset + m ≤ n) (v : Fin n → α) (j : Fin n)\n  (hj : j.val < offset ∨ offset + m ≤ j.val) :\n  (net.shiftEmbed n offset h).exec v j = v j",
      desc: "A shifted+embedded network does not modify positions outside its range." },
    // ── Tree/AKSNetwork.lean — iterated halver helpers ──
    { id: "epsHalverMerge_exec_eq_iterate", file: "AKS/Tree/AKSNetwork.lean", line: 28, status: "proved", kind: "theorem",
      sig: "epsHalverMerge_exec_eq_iterate : (epsHalverMerge n ε k halver).exec v = Nat.iterate (fun w ↦ halver.exec w) k v",
      desc: "Executing epsHalverMerge is iterating the halver's exec." },
    { id: "epsHalverMerge_size", file: "AKS/Tree/AKSNetwork.lean", line: 41, status: "proved", kind: "theorem",
      sig: "epsHalverMerge_size : (epsHalverMerge n ε k halver).size = k * halver.size",
      desc: "Size of epsHalverMerge is k times the halver size." },
    { id: "mono_of_iterate_mono", file: "AKS/Tree/AKSNetwork.lean", line: 49, status: "proved", kind: "theorem",
      sig: "mono_of_iterate_mono : k₁ ≤ k₂ → Monotone (iterate f k₁ v) → Monotone (iterate f k₂ v)",
      desc: "If iterating k₁ times produces a monotone result, so does iterating k₂ ≥ k₁ times." },
    { id: "aks_size_bound", file: "AKS/Tree/AKSNetwork.lean", line: 83, status: "proved", kind: "theorem",
      sig: "aks_size_bound : 100 * Nat.log 2 (2*m) * s ≤ 100*(d+1)*(2*m)*log(2*m)",
      desc: "Size arithmetic for the AKS construction using Nat.log ≤ logb and log 2 > 1/2." },

    // ── Halver.lean ──
    { id: "IsEpsilonHalver", file: "AKS/Halver/Defs.lean", line: 131, status: "definition", kind: "def",
      sig: "IsEpsilonHalver (net : ComparatorNetwork n) (ε : ℝ) : Prop",
      desc: "ε-halver (AKS Section 3, permutation-based): for every permutation input, output is ε-halved — segment-wise bounds on displaced elements using rank." },
    { id: "expanderHalver", file: "AKS/Halver/ExpanderToHalver.lean", line: 51, status: "proved", kind: "definition",
      sig: "expanderHalver (G : RegularGraph m d) : ComparatorNetwork (2 * m)",
      desc: "The bipartite halver comparator network from a d-regular expander. For each vertex v and port p, compares wire v with wire m + G.neighbor v p." },
    { id: "expanderHalver_isEpsilonHalver", file: "AKS/Halver/ExpanderToHalver.lean", line: 649, status: "proved", kind: "theorem",
      sig: "expanderHalver_isEpsilonHalver (G : RegularGraph m d) (β : ℝ) (hβ : spectralGap G ≤ β) :\n  IsEpsilonHalver (expanderHalver G) β",
      desc: "The expander halver is a β-halver. Proved via Tanner's vertex expansion bound + edge monotonicity + permutation counting." },
    { id: "expanderHalver_size", file: "AKS/Halver/ExpanderToHalver.lean", line: 658, status: "proved", kind: "theorem",
      sig: "expanderHalver_size (G : RegularGraph m d) : (expanderHalver G).size = m * d",
      desc: "The expander halver has exactly m·d comparators (linear in m since d is constant)." },
    { id: "RegBipartite", file: "AKS/Konig/Defs.lean", line: 25, status: "definition", kind: "def",
      sig: "structure RegBipartite (m d : ℕ) where\n  edges : Fin m → Fin d → Fin m\n  bot_regular : ∀ u, ((univ ×ˢ univ).filter ...).card = d",
      desc: "Bottom-regular bipartite multigraph: m top vertices, m bottom vertices, d ports per top vertex, each bottom vertex has exactly d incoming edges." },
    { id: "hall_condition", file: "AKS/Konig/Hall.lean", line: 26, status: "proved", kind: "theorem",
      sig: "RegBipartite.hall_condition (B : RegBipartite m d) (hd : 0 < d)\n  (S : Finset (Fin m)) : S.card ≤ (S.biUnion (fun v ↦ univ.image (B.edges v))).card",
      desc: "Hall's condition for d-regular bipartite multigraphs via double counting: d·|S| edges leave S, each bottom vertex absorbs ≤ d." },
    { id: "konigMatchings_bijective", file: "AKS/Konig/Coloring.lean", line: 196, status: "proved", kind: "theorem",
      sig: "RegBipartite.konigMatchings_bijective (B : RegBipartite m d) (hd : 0 < d) (v : Fin m) :\n  Function.Bijective (fun k ↦ (B.konigMatchings hd k).portOf v)",
      desc: "König's edge coloring: d-regular bipartite multigraph decomposes into d perfect matchings that partition all ports at each vertex." },
    { id: "exists_halver_depth_le", file: "AKS/Halver/ExpanderToHalver.lean", line: 923, status: "proved", kind: "theorem",
      sig: "exists_halver_depth_le (G : RegularGraph m d) (β : ℝ) (hβ : spectralGap G ≤ β) :\n  ∃ net, IsEpsilonHalver net β ∧ net.size ≤ m * d ∧ net.depth ≤ d",
      desc: "A depth-d halver exists from any d-regular expander. Proved via König's edge coloring: decompose bipartite comparators into d parallel matching layers." },
    { id: "HalverFamily", file: "AKS/Halver/Defs.lean", line: 297, status: "definition", kind: "def",
      sig: "structure HalverFamily (ε : ℝ) (d : ℕ) where\n  net : (m : ℕ) → ComparatorNetwork (2 * m)\n  isHalver : ∀ m, IsEpsilonHalver (net m) ε\n  depth_le : ∀ m, (net m).depth ≤ d",
      desc: "Family of ε-halver networks indexed by half-size m, with depth bounded by d. Bundles net + halver proof + depth bound." },
    { id: "size_le_half_n_mul_depth", file: "AKS/Sort/Depth.lean", line: 262, status: "proved", kind: "theorem",
      sig: "size_le_half_n_mul_depth (net : ComparatorNetwork n) :\n  2 * net.size ≤ n * net.depth",
      desc: "Each comparator increases total wire-time sum by ≥ 2; the sum is ≤ n * depth. So 2 * size ≤ n * depth." },
    { id: "HalverFamily.size_le", file: "AKS/Halver/Defs.lean", line: 307, status: "proved", kind: "theorem",
      sig: "HalverFamily.size_le (family : HalverFamily ε d) (m : ℕ) :\n  (family.net m).size ≤ m * d",
      desc: "Depth ≤ d on 2m bipartite wires implies size ≤ m * d. Proved via size_le_half_n_mul_depth." },
    { id: "expanderHalverFamily", file: "AKS/Halver/ExpanderToHalver.lean", line: 976, status: "proved", kind: "def",
      sig: "expanderHalverFamily {d : ℕ} (β : ℝ)\n  (graphs : ∀ m, m > 0 → RegularGraph m d)\n  (hgaps : ∀ m (hm : m > 0), spectralGap (graphs m hm) ≤ β) :\n  HalverFamily β d",
      desc: "Builds a HalverFamily from an expander family via exists_halver_depth_le." },
    { id: "shrinkHalver", file: "AKS/Halver/Shrink.lean", line: 37, status: "proved", kind: "definition",
      sig: "shrinkHalver (net : ComparatorNetwork (2 * M)) (n : ℕ) (hn : n ≤ M) :\n  ComparatorNetwork (2 * n)",
      desc: "Restrict a bipartite halver on 2M wires to 2n wires, keeping only comparators with both endpoints in first n wires per half." },
    { id: "shrinkHalver_isEpsilonHalver", file: "AKS/Halver/Shrink.lean", line: 569, status: "proved", kind: "theorem",
      sig: "shrinkHalver_isEpsilonHalver : IsEpsilonHalver (shrinkHalver net n hnM) (ε * (M - n + 1))",
      desc: "Shrinking preserves halver quality: if net is an ε-halver on 2M, shrinkHalver is an ε*(M-n+1)-halver on 2n. Proved via padding argument + injection." },
    { id: "tanner_bound", file: "AKS/Halver/Tanner.lean", line: 216, status: "proved", kind: "theorem",
      sig: "tanner_bound (G : RegularGraph n d) (β : ℝ) (hβ : spectralGap G ≤ β) (T : Finset (Fin n)) :\n  |T|·n ≤ |N(T)|·(|T| + β²(n-|T|))",
      desc: "Tanner's vertex expansion bound: for any T in a d-regular graph with spectral gap ≤ β, |N(T)| ≥ |T|·n/(|T| + β²(n-|T|)). Proved via Cauchy-Schwarz on codegree distribution + orthogonal decomposition." },
    { id: "epsHalverMerge", file: "AKS/Halver/Defs.lean", line: 139, status: "definition", kind: "def",
      sig: "epsHalverMerge (n ε : ℝ) (k : ℕ) (halver : ComparatorNetwork n) : ComparatorNetwork n",
      desc: "Iterated halver merge: apply halver k times for geometric convergence." },
    { id: "IsEpsilonSorted", file: "AKS/Halver/Defs.lean", line: 191, status: "definition", kind: "def",
      sig: "IsEpsilonSorted (v : Fin n → Bool) (ε : ℝ) : Prop",
      desc: "ε-sortedness: at most ε·n elements are out of place." },
    { id: "Monotone.bool_pattern", file: "AKS/Halver/Defs.lean", line: 205, status: "proved", kind: "lemma",
      sig: "Monotone.bool_pattern (w : Fin n → Bool) (hw : Monotone w) :\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w ⟨i, ·⟩ = false) ∧ (∀ i, k ≤ i → w ⟨i, ·⟩ = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: a prefix of falses followed by trues. Threshold found via Nat.find." },
    // NOTE: wrongness, halver_decreases_wrongness, halver_composition, halver_convergence
    // have been deleted — superseded by tree-based approach in Tree/Sorting.lean

    // ── Nearsort/Construction.lean ──
    { id: "halverAtLevel_size", file: "AKS/Nearsort/Construction.lean", line: 100, status: "proved", kind: "theorem",
      sig: "halverAtLevel_size (n : ℕ) (halvers : (m : ℕ) → ComparatorNetwork (2 * m))\n  (d : ℕ) (hhalver_size : ∀ m, (halvers m).size ≤ m * d) (level : ℕ) :\n  (halverAtLevel n halvers level).size ≤ n * d",
      desc: "Sub-interval halver sizes sum to at most n * d at each level. Uses chunks_times_halfChunk_le." },
    { id: "halverNetwork_size", file: "AKS/Nearsort/Construction.lean", line: 124, status: "proved", kind: "theorem",
      sig: "halverNetwork_size (n : ℕ) (halvers : (m : ℕ) → ComparatorNetwork (2 * m))\n  (d : ℕ) (hhalver_size : ∀ m, (halvers m).size ≤ m * d) (depth : ℕ) :\n  (halverNetwork n halvers depth).size ≤ depth * (n * d)",
      desc: "Total halver network size is at most depth * (n * d). Sums halverAtLevel_size over all levels." },
    // ── Nearsort/Correctness.lean ──
    { id: "farSmallCount_depth_bound", file: "AKS/Nearsort/Correctness.lean", line: 434, status: "sorry", kind: "theorem",
      sig: "farSmallCount_depth_bound {n : ℕ} (ε : ℝ) (depth : ℕ) ... :\n  farSmallCount (halverNetwork.exec v) k (n / 2^depth) ≤ ε * depth * k",
      desc: "After depth levels, far-small count at radius n/2^depth is ≤ ε·depth·k. Core of AKS Section 4: requires trajectory/displaced-elements argument with union bound over levels.", difficulty: "weeks" },
    { id: "farLargeCount_depth_bound", file: "AKS/Nearsort/Correctness.lean", line: 629, status: "sorry", kind: "theorem",
      sig: "farLargeCount_depth_bound {n : ℕ} (ε : ℝ) (depth : ℕ) ... :\n  farLargeCount (halverNetwork.exec v) k (n / 2^depth) ≤ ε * depth * k",
      desc: "Dual of farSmallCount_depth_bound for end segments.", difficulty: "weeks" },
    { id: "halverNetwork_initialNearsorted", file: "AKS/Nearsort/Correctness.lean", line: 540, status: "proved", kind: "theorem",
      sig: "halverNetwork_initialNearsorted {n : ℕ} (ε : ℝ) (depth d : ℕ)\n  (hε : 0 < ε) (hε1 : ε < 1 / 2) ... (v : Equiv.Perm (Fin n)) :\n  InitialNearsorted ((halverNetwork n halvers depth).exec v) (ε * ↑depth)",
      desc: "Initial-segment nearsort bound. Reformulates as farSmallCount via sdiff_image_card_eq_far_count, then applies depth bound + blowup_covers_displacement." },
    { id: "halverNetwork_finalNearsorted", file: "AKS/Nearsort/Correctness.lean", line: 711, status: "proved", kind: "theorem",
      sig: "halverNetwork_finalNearsorted {n : ℕ} (ε : ℝ) (depth d : ℕ)\n  (hε : 0 < ε) (hε1 : ε < 1 / 2) ... (v : Equiv.Perm (Fin n)) :\n  FinalNearsorted ((halverNetwork n halvers depth).exec v) (ε * ↑depth)",
      desc: "Dual: final-segment nearsortedness via farLargeCount_depth_bound and rank_fin_od_val." },
    // ── Nearsort/HalverToNearsort.lean ──
    { id: "halver_family_gives_nearsort", file: "AKS/Nearsort/HalverToNearsort.lean", line: 59, status: "proved", kind: "theorem",
      sig: "halver_family_gives_nearsort {n : ℕ} (ε : ℝ) (depth d : ℕ)\n  (hε : 0 < ε) (hε1 : ε < 1 / 2) ... :\n  ∃ (net : ComparatorNetwork n), Nearsort net (halverNearsortQuality ε depth) ∧\n    (net.size : ℝ) ≤ ↑depth * ↑d * ↑n",
      desc: "ε-halver family → δ-nearsort (AKS Section 4). Assembles halverNetwork_initialNearsorted, halverNetwork_finalNearsorted, and halverNetwork_size." },

    // ── ZigZag/Operators.lean ──
    { id: "RegularGraph.zigzag", file: "AKS/ZigZag/Operators.lean", line: 284, status: "definition", kind: "def",
      sig: "RegularGraph.zigzag (G₁ : RegularGraph n₁ d₁) (G₂ : RegularGraph d₁ d₂) :\n  RegularGraph (n₁ * d₁) (d₂ * d₂)",
      desc: "Zig-zag product: combines a big graph G₁ with a small graph G₂. Three-step walk: zig, step, zag." },
    { id: "withinClusterCLM", file: "AKS/ZigZag/Operators.lean", line: 146, status: "definition", kind: "def",
      sig: "withinClusterCLM (G₂ : RegularGraph d₁ d₂) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Within-cluster walk operator B = I ⊗ W_{G₂}: walks within each cluster using G₂." },
    { id: "stepPermCLM", file: "AKS/ZigZag/Operators.lean", line: 185, status: "definition", kind: "def",
      sig: "stepPermCLM (G₁ : RegularGraph n₁ d₁) (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Step permutation operator Σ: permutes via G₁.rot, swapping between clusters." },
    { id: "clusterMeanCLM", file: "AKS/ZigZag/Operators.lean", line: 222, status: "definition", kind: "def",
      sig: "clusterMeanCLM (hd₁ : 0 < d₁) :\n  EuclideanSpace ℝ (Fin (n₁ * d₁)) →L[ℝ] ...",
      desc: "Cluster mean operator Q: averages within each cluster (projects onto cluster-constant functions)." },
    { id: "zigzag_walkCLM_eq", file: "AKS/ZigZag/Operators.lean", line: 325, status: "proved", kind: "theorem",
      sig: "zigzag_walkCLM_eq : (G₁.zigzag G₂).walkCLM = B * Σ * B",
      desc: "Walk factorization: the zig-zag walk operator equals B · Σ · B." },

    // ── ZigZag/Spectral.lean ──
    { id: "clusterMeanCLM_idempotent", file: "AKS/ZigZag/Spectral.lean", line: 22, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_idempotent : Q * Q = Q",
      desc: "Cluster mean is idempotent (it's a projection)." },
    { id: "clusterMeanCLM_isSelfAdjoint", file: "AKS/ZigZag/Spectral.lean", line: 31, status: "proved", kind: "theorem",
      sig: "clusterMeanCLM_isSelfAdjoint : IsSelfAdjoint Q",
      desc: "Cluster mean is self-adjoint." },
    { id: "withinClusterCLM_isSelfAdjoint", file: "AKS/ZigZag/Spectral.lean", line: 112, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_isSelfAdjoint : IsSelfAdjoint B",
      desc: "Within-cluster walk is self-adjoint (inherits from G₂)." },
    { id: "withinCluster_comp_clusterMean", file: "AKS/ZigZag/Spectral.lean", line: 160, status: "proved", kind: "theorem",
      sig: "withinCluster_comp_clusterMean : B * Q = Q",
      desc: "Walking within clusters then averaging = just averaging (BQ = Q)." },
    { id: "clusterMean_comp_withinCluster", file: "AKS/ZigZag/Spectral.lean", line: 179, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_withinCluster : Q * B = Q",
      desc: "Averaging then walking within clusters = just averaging (QB = Q)." },
    { id: "withinClusterCLM_norm_le_one", file: "AKS/ZigZag/Spectral.lean", line: 200, status: "proved", kind: "theorem",
      sig: "withinClusterCLM_norm_le_one : ‖B‖ ≤ 1",
      desc: "Within-cluster walk is a contraction." },
    { id: "stepPermCLM_sq_eq_one", file: "AKS/ZigZag/Spectral.lean", line: 249, status: "proved", kind: "theorem",
      sig: "stepPermCLM_sq_eq_one : Σ * Σ = 1",
      desc: "Step permutation is an involution (because G₁.rot is)." },
    { id: "stepPermCLM_isSelfAdjoint", file: "AKS/ZigZag/Spectral.lean", line: 262, status: "proved", kind: "theorem",
      sig: "stepPermCLM_isSelfAdjoint : IsSelfAdjoint Σ",
      desc: "Step permutation is self-adjoint (orthogonal involution)." },
    { id: "stepPermCLM_comp_meanCLM", file: "AKS/ZigZag/Spectral.lean", line: 648, status: "proved", kind: "theorem",
      sig: "stepPermCLM_comp_meanCLM : Σ * P = P",
      desc: "Step permutation absorbs mean projection (permuting a constant is identity)." },
    { id: "withinCluster_tilde_contraction", file: "AKS/ZigZag/Spectral.lean", line: 492, status: "proved", kind: "theorem",
      sig: "withinCluster_tilde_contraction : ‖B(I - Q)‖ ≤ spectralGap G₂",
      desc: "Within-cluster walk restricted to non-constant part contracts by λ(G₂). Block-diagonal argument with per-cluster spectral gap." },
    { id: "hat_block_norm", file: "AKS/ZigZag/Spectral.lean", line: 582, status: "proved", kind: "theorem",
      sig: "hat_block_norm : ‖QΣQ - P‖ ≤ spectralGap G₁",
      desc: "The 'hat' operator QΣQ minus global mean is bounded by λ(G₁)." },
    { id: "meanCLM_eq_clusterMean_comp", file: "AKS/ZigZag/Spectral.lean", line: 552, status: "proved", kind: "theorem",
      sig: "meanCLM_eq_clusterMean_comp : P * Q = P",
      desc: "Global mean composed with cluster mean = global mean." },
    { id: "clusterMean_comp_meanCLM", file: "AKS/ZigZag/Spectral.lean", line: 567, status: "proved", kind: "theorem",
      sig: "clusterMean_comp_meanCLM : Q * P = P",
      desc: "Cluster mean composed with global mean = global mean." },

    // ── ZigZag/RVWBound.lean ──
    { id: "rvwBound", file: "AKS/ZigZag/RVWBound.lean", line: 39, status: "definition", kind: "def",
      sig: "rvwBound (lam₁ lam₂ : ℝ) : ℝ",
      desc: "The precise Reingold-Vadhan-Wigderson bound function for zig-zag spectral composition." },
    { id: "rvwBound_mono_left", file: "AKS/ZigZag/RVWBound.lean", line: 193, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_left : a₁ ≤ a₂ → rvwBound a₁ b ≤ rvwBound a₂ b",
      desc: "RVW bound is monotone in the first argument." },
    { id: "rvwBound_mono_right", file: "AKS/ZigZag/RVWBound.lean", line: 207, status: "proved", kind: "theorem",
      sig: "rvwBound_mono_right : b₁ ≤ b₂ → rvwBound a b₁ ≤ rvwBound a b₂",
      desc: "RVW bound is monotone in the second argument." },
    { id: "rvw_quadratic_ineq", file: "AKS/ZigZag/RVWInequality.lean", line: 376, status: "proved", kind: "lemma",
      sig: "rvw_quadratic_ineq : (p+2q+r)² ≤ (1-μ₂²)μ₁|p+2q+r| + μ₂²",
      desc: "Core quadratic inequality for RVW bound. Proved via a-quadratic case analysis: disc ≤ 0 or vertex outside [0,1]." },
    { id: "rayleigh_quotient_bound", file: "AKS/ZigZag/RVWBound.lean", line: 332, status: "retired", kind: "lemma",
      sig: "rayleigh_quotient_bound : ‖A‖ = sSup (range (fun x ↦ |⟨Ax, x⟩|))",
      desc: "Rayleigh quotient characterization of self-adjoint operator norm. Deleted — was unused." },
    { id: "rvw_operator_norm_bound", file: "AKS/ZigZag/RVWBound.lean", line: 1101, status: "proved", kind: "theorem",
      sig: "rvw_operator_norm_bound : ‖W - P‖ ≤ rvwBound lam₁ lam₂",
      desc: "Core RVW bound: abstract operator inequality from projection/contraction axioms. Uses hat/tilde decomposition, reflection Rayleigh quotients, and the RVW quadratic inequality." },

    // ── Cert/WalkBound.lean ──
    { id: "spectralGap_le_of_walk_bound", file: "AKS/Cert/WalkBound.lean", line: 26, status: "proved", kind: "theorem",
      sig: "spectralGap_le_of_walk_bound : (∀ f, meanCLM n f = 0 → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²) → spectralGap G ≤ √(c₁/(c₂·d²))",
      desc: "Walk bound on mean-zero vectors implies spectral gap bound via operator norm characterization." },
    { id: "sqrt_coeff_le_frac", file: "AKS/Cert/WalkBound.lean", line: 75, status: "proved", kind: "theorem",
      sig: "sqrt_coeff_le_frac : c₁·βd² ≤ c₂·βn² → √(c₁/(c₂·d²)) ≤ βn/(βd·d)",
      desc: "Coefficient arithmetic: converts walk bound ratio to rational fraction." },

    // ── Cert/SpectralMatrix.lean ──
    { id: "spectralMatrix", file: "AKS/Cert/SpectralMatrix.lean", line: 33, status: "definition", kind: "def",
      sig: "spectralMatrix G c₁ c₂ c₃ = c₁·I - c₂·A² + c₃·J\n  where A = d · adjMatrix G (unnormalized)",
      desc: "Spectral matrix M = c₁I - c₂A² + c₃J with unnormalized adjacency A = d · adjMatrix." },
    { id: "spectralMatrix_isHermitian", file: "AKS/Cert/SpectralMatrix.lean", line: 43, status: "proved", kind: "theorem",
      sig: "spectralMatrix_isHermitian : (spectralMatrix G c₁ c₂ c₃).IsHermitian",
      desc: "Spectral matrix is Hermitian (real symmetric)." },
    { id: "spectralMatrix_posSemidef_implies_walk_bound", file: "AKS/Cert/SpectralMatrix.lean", line: 119, status: "proved", kind: "theorem",
      sig: "spectralMatrix_posSemidef_implies_walk_bound :\n  M.PosSemidef → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²",
      desc: "Layer 1: PSD spectral matrix implies walk bound. Proof: PSD → nonneg quadratic form, J vanishes on mean-zero vectors, unnormalized adjacency gives d² factor." },

    // ── Cert/DiagDominant.lean ──
    { id: "diagDominant_isUnit", file: "AKS/Cert/DiagDominant.lean", line: 25, status: "proved", kind: "theorem",
      sig: "diagDominant_isUnit : (∀ k, ∑ j≠k ‖M k j‖ < ‖M k k‖) → IsUnit M",
      desc: "Strict row diagonal dominance implies invertibility via Gershgorin circle theorem." },
    { id: "diagDominant_posSemidef", file: "AKS/Cert/DiagDominant.lean", line: 55, status: "proved", kind: "theorem",
      sig: "diagDominant_posSemidef : M.IsHermitian → (∀ i, ∑ j≠i ‖M i j‖ < M i i) → M.PosSemidef",
      desc: "Layer 2: Hermitian + strict diagonal dominance implies PSD. Direct quadratic form bound via AM-GM regrouping." },

    // ── Cert/Bridge.lean ──
    { id: "certMatrixReal", file: "AKS/Cert/Bridge.lean", line: 38, status: "definition", kind: "def",
      sig: "certMatrixReal (certBytes : ByteArray) (n : ℕ) : Matrix (Fin n) (Fin n) ℝ",
      desc: "Certificate matrix Z decoded from base-85 bytes. Upper triangular: Z[i,j] = 0 for i > j." },
    { id: "certMatrix_posdiag", file: "AKS/Cert/Bridge.lean", line: 63, status: "proved", kind: "theorem",
      sig: "certMatrix_posdiag :\n  checkPSDCertificate = true → ∀ j, 0 < Z j j",
      desc: "Certificate matrix has positive diagonal when PSD checker passes. Proved by extracting allDiagPositive check from the augmented checker via induction." },
    { id: "kRowDominant_implies_diagDominant", file: "AKS/Cert/Bridge.lean", line: 400, status: "proved", kind: "theorem",
      sig: "kRowDominant_implies_diagDominant :\n  checkAllRowsDomPure = true → hmatch → ∀ i, ∑ j≠i ‖K i j‖ < K i i",
      desc: "Bridge: pure functional checker matches formal star Z * M * Z. Proved via chain: certEntry↔Z, adjMul↔unnorm_adj, pEntry↔M*Z, kEntry↔Z*M*Z, then integer diag-dominance → real." },
    { id: "checkColumnNormBoundPure_spec", file: "AKS/Cert/Bridge.lean", line: 328, status: "proved", kind: "theorem",
      sig: "checkColumnNormBoundPure_spec :\n  checkColumnNormBoundPure = true → Z[i,i]·(δ+ε) > ε·T_i",
      desc: "Per-row column-norm inequality. Proved by induction on checkPerRow (pure recursive checker)." },
    { id: "congruence_diagDominant", file: "AKS/Cert/Bridge.lean", line: 500, status: "proved", kind: "theorem",
      sig: "congruence_diagDominant :\n  checkCertificate = true → ∀ i, ∑ j≠i ‖K i j‖ < K i i",
      desc: "K = Z*MZ is strictly row-diag-dominant. Fully proved via checkColumnNormBound_spec + column-norm bounds." },
    { id: "checker_implies_spectralMatrix_psd", file: "AKS/Cert/Bridge.lean", line: 757, status: "proved", kind: "theorem",
      sig: "checker_implies_spectralMatrix_psd :\n  checkCertificate = true → (spectralMatrix G c₁ c₂ c₃).PosSemidef",
      desc: "Layer 3: certificate checker passes → spectral matrix PSD. Proof: Z upper-tri + pos-diag → invertible; K=Z*MZ Hermitian + diag-dominant → PSD; congruence → M PSD." },
    { id: "certificate_implies_walk_bound", file: "AKS/Cert/Bridge.lean", line: 809, status: "proved", kind: "theorem",
      sig: "certificate_implies_walk_bound :\n  checkCertificate = true → c₂·d²·‖Wf‖² ≤ c₁·‖f‖²",
      desc: "Certificate → walk bound. Chains Layer 3 (certificate → PSD) with Layer 1 (PSD → walk bound)." },
    { id: "certificate_bridge", file: "AKS/Cert/Bridge.lean", line: 845, status: "proved", kind: "theorem",
      sig: "certificate_bridge :\n  checkCertificate = true → spectralGap G ≤ βn/(βd·d)",
      desc: "Full bridge: certificate → spectral gap bound. Chains walk bound, spectralGap_le_of_walk_bound, and sqrt_coeff_le_frac.", milestone: true },

    // ── Cert/FastProof.lean ──
    { id: "checkCertificateFast_eq_slow", file: "AKS/Cert/FastProof.lean", line: 46, status: "proved", kind: "theorem",
      sig: "checkCertificateFast_eq_slow :\n  @checkCertificateFast = @checkCertificateSlow",
      desc: "Bridge: parallel fused checker = sequential checker. Proof: Task elimination, fused→unfused PSD rewrite, Boolean case splits, prefix-sum loop = checkPerRow via fused_norm_lookup." },

    // ── Random/Random16.lean ──
    { id: "Random16.graph", file: "AKS/Random/Random16.lean", line: 23, status: "proved", kind: "def",
      sig: "def Random16.graph : RegularGraph 16 4",
      desc: "Concrete 4-regular graph on 16 vertices. Small test graph, rotation map verified by native_decide." },
    { id: "Random16.gap", file: "AKS/Random/Random16.lean", line: 33, status: "proved", kind: "theorem",
      sig: "theorem Random16.gap : spectralGap graph ≤ 5/4",
      desc: "Spectral gap bound via certificate bridge. Fully proved: certificate (n=16) verified by native_decide." },

    // ── Random/Random1728.lean ──
    { id: "Random1728.graph", file: "AKS/Random/Random1728.lean", line: 23, status: "proved", kind: "def",
      sig: "def Random1728.graph : RegularGraph 1728 12",
      desc: "Concrete 12-regular graph on 1728 = 12³ vertices. Medium test graph, rotation map verified by native_decide." },
    { id: "Random1728.gap", file: "AKS/Random/Random1728.lean", line: 33, status: "proved", kind: "theorem",
      sig: "theorem Random1728.gap : spectralGap graph ≤ 10/12",
      desc: "Spectral gap bound via certificate bridge. Fully proved: certificate (n=1728) verified by native_decide." },

    // ── Random/Random20736.lean ──
    { id: "Random20736.graph", file: "AKS/Random/Random20736.lean", line: 26, status: "proved", kind: "def",
      sig: "def Random20736.graph : RegularGraph 20736 12",
      desc: "Concrete 12-regular graph on 20736 = 12⁴ vertices. Rotation map loaded from data file, involution verified by native_decide." },
    { id: "Random20736.gap", file: "AKS/Random/Random20736.lean", line: 37, status: "proved", kind: "theorem",
      sig: "theorem Random20736.gap : spectralGap graph ≤ 10/12",
      desc: "Spectral gap bound via certificate bridge. PSD certificate (821 MB) verified by native_decide." },
    // Retired nodes — hidden in live view, visible when scrubbing to historical snapshots
    { id: "baseExpander", file: "AKS/Random/Random20736.lean", line: 31, status: "retired", kind: "axiom",
      sig: "axiom baseExpander : RegularGraph 20736 12",
      desc: "Retired: replaced by Random20736.graph." },
    { id: "baseExpander_gap", file: "AKS/Random/Random20736.lean", line: 41, status: "retired", kind: "axiom",
      sig: "axiom baseExpander_gap : spectralGap baseExpander ≤ 5/9",
      desc: "Retired: replaced by Random20736.gap." },

    // ── ZigZag/Expanders.lean ──
    { id: "zigzag_spectral_bound", file: "AKS/ZigZag/Expanders.lean", line: 30, status: "proved", kind: "theorem",
      sig: "zigzag_spectral_bound : spectralGap (G₁.zigzag G₂) ≤ rvwBound lam₁ lam₂",
      desc: "Zig-zag spectral composition: assembles all sublemmas into the final bound. Degenerate case (n₁·d₁=0) handled via rvwBound ≥ 0; main case chains through rvw_operator_norm_bound." },
    { id: "zigzagFamily", file: "AKS/ZigZag/Expanders.lean", line: 124, status: "definition", kind: "def",
      sig: "zigzagFamily (H₀ : RegularGraph ((D*D)*(D*D)) D) : ℕ → Σ n, RegularGraph n (D*D)",
      desc: "Iterated zig-zag construction: square then zig-zag with base, producing growing expander families." },
    { id: "zigzagFamily_gap", file: "AKS/ZigZag/Expanders.lean", line: 138, status: "proved", kind: "theorem",
      sig: "zigzagFamily_gap : spectralGap (zigzagFamily H₀ k).2 ≤ c",
      desc: "Every graph in the zig-zag family has spectral gap ≤ c. Proved by induction using squaring + zig-zag bounds." },
    { id: "explicit_expanders_exist_zigzag", file: "AKS/ZigZag/Expanders.lean", line: 168, status: "sorry", kind: "theorem",
      sig: "explicit_expanders_exist_zigzag :\n  ∀ n > 0, ∃ G : RegularGraph n (D*D), spectralGap G ≤ c",
      desc: "Explicit expanders exist at every size via interpolation from the zig-zag family.", difficulty: "weeks" },

    // ── Tree/AKSNetwork.lean — top-level parameterized theorem ──
    { id: "zigzag_implies_aks_network", file: "AKS/Tree/AKSNetwork.lean", line: 164, status: "proved", kind: "theorem",
      sig: "zigzag_implies_aks_network {β : ℝ} (hβ_pos : 0 < β) (hβ_half : β < 1/2) :\n  (∃ d, ∀ n > 0, ∃ G, spectralGap G ≤ β) →\n  ∃ c > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ c·n·log n",
      desc: "Parameterized AKS theorem: expander family → O(n log n) sorting networks. Builds HalverFamily via expanderHalverFamily, calls aks_tree_sorting." },

    // ── AKS/Main.lean — top-level assembly via iterated squaring ──
    { id: "squareIter", file: "AKS/Main.lean", line: 35, status: "definition", kind: "def",
      sig: "RegularGraph.squareIter (G : RegularGraph n d) :\n  (k : ℕ) → RegularGraph n (d ^ (2 ^ k))",
      desc: "Iterated graph squaring: square k times, yielding d^(2^k)-regular graph on n vertices." },
    { id: "spectralGap_squareIter", file: "AKS/Main.lean", line: 41, status: "proved", kind: "theorem",
      sig: "spectralGap_squareIter :\n  spectralGap (G.squareIter k) = (spectralGap G) ^ (2 ^ k)",
      desc: "Spectral gap of k-th iterated square is the 2^k-th power of the original gap." },
    { id: "exists_pow_two_pow_lt", file: "AKS/Main.lean", line: 54, status: "proved", kind: "theorem",
      sig: "exists_pow_two_pow_lt : 0 ≤ c → c < 1 → 0 < t → ∃ k, c ^ (2^k) < t",
      desc: "Doubly-exponential convergence: c^(2^k) eventually drops below any positive target." },
    { id: "expander_family_small_gap", file: "AKS/Main.lean", line: 66, status: "proved", kind: "theorem",
      sig: "expander_family_small_gap :\n  ... → 0 < c → c < 1 → 0 < β →\n  ∃ d, ∀ n > 0, ∃ G : RegularGraph n d, spectralGap G ≤ β",
      desc: "Zig-zag + iterated squaring gives constant-degree expander family with arbitrarily small spectral gap." },
    { id: "aks_sorting_networks_exist", file: "AKS/Main.lean", line: 106, status: "proved", kind: "theorem",
      sig: "aks_sorting_networks_exist :\n  ... → 0 < c → c < 1 →\n  ∃ C > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ C·n·log n",
      desc: "AKS (1983): O(n log n) sorting networks exist, from base expander + zig-zag + squaring + tree sorting." },

    // ── Seiferas.lean (Seiferas-path assembly, parallel to Main.lean) ──
    { id: "expanderToHalverFamily", file: "AKS/Seiferas.lean", line: 101, status: "proved", kind: "def",
      sig: "expanderToHalverFamily (β : ℝ)\n  (hfamily : ∀ n > 0, ∃ G : RegularGraph n d, spectralGap G ≤ β) :\n  HalverFamily β d",
      desc: "Wraps expanderHalverFamily: expander family → halver family with error β and depth d." },
    { id: "halverToSeparatorFamily'", file: "AKS/Seiferas.lean", line: 114, status: "sorry", kind: "def",
      sig: "halverToSeparatorFamily' (family : HalverFamily ε d) (hε : 0 ≤ ε) (t : ℕ) :\n  SeparatorFamily (1/2^t) (t*ε) (t*d)",
      desc: "Halver family → separator family via iterated halving. Depth proved; isSep sorry (needs 2^t ∣ n for all n, subsumed by separatorSortingNetwork_sorts sorry)." },
    { id: "seiferas_implies_sorting_network", file: "AKS/Seiferas.lean", line: 141, status: "sorry", kind: "theorem", milestone: true,
      sig: "seiferas_implies_sorting_network :\n  0 < β → β < 1 → (∃ d, ∀ n > 0, ∃ G, spectralGap G ≤ β) →\n  ∃ C > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ C·n·log n",
      desc: "Parameterized Seiferas theorem: expander family → O(n log n) sorting. Size bound fully proved; correctness forwards sorry from separatorSortingNetwork_sorts." },
    { id: "seiferas_sorting_networks_exist", file: "AKS/Seiferas.lean", line: 217, status: "sorry", kind: "theorem", milestone: true,
      sig: "seiferas_sorting_networks_exist :\n  ... → 0 < c → c < 1 →\n  ∃ C > 0, ∀ n ≥ 2, ∃ net, IsSortingNetwork net ∧ net.size ≤ C·n·log n",
      desc: "Seiferas (2009): O(n log n) sorting networks exist, from base expander + zig-zag + squaring + separator/bags path. Parallel to aks_sorting_networks_exist." },

    // ── Tree/Sorting.lean ──
    { id: "TreeNode", file: "AKS/Tree/Sorting.lean", line: 105, status: "definition", kind: "structure",
      sig: "structure TreeNode where\n  level : ℕ\n  index : ℕ",
      desc: "Position (level, index) in binary tree for register assignment." },
    { id: "treeWrongness", file: "AKS/Tree/Sorting.lean", line: 1737, status: "definition", kind: "def",
      sig: "treeWrongness (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : ℝ",
      desc: "Tree-based wrongness measure Δᵣ(J): proportion of elements at tree-distance ≥ r from their target." },
    { id: "halver_preserves_monotone", file: "AKS/Tree/Sorting.lean", line: 2485, status: "proved", kind: "lemma",
      sig: "halver_preserves_monotone : IsEpsilonHalver net ε → Monotone w → Monotone (net.exec w)",
      desc: "Applying an ε-halver to a monotone sequence preserves monotonicity." },
    { id: "monotone_bool_zeros_then_ones", file: "AKS/Tree/Sorting.lean", line: 1606, status: "proved", kind: "lemma",
      sig: "monotone_bool_zeros_then_ones : Monotone w →\n  ∃ k, k ≤ n ∧ (∀ i, i < k → w i = false) ∧ (∀ i, k ≤ i → w i = true)",
      desc: "Monotone Boolean sequences have 0*1* pattern: threshold detected via Nat.find.", difficulty: "days" },
    { id: "countOnes_le", file: "AKS/Halver/Defs.lean", line: 31, status: "proved", kind: "lemma",
      sig: "countOnes_le : countOnes v ≤ n",
      desc: "Count of ones bounded by total elements (filter cardinality)." },
    { id: "countOnes_split", file: "AKS/Tree/Sorting.lean", line: 1563, status: "proved", kind: "lemma",
      sig: "countOnes_split : countOnes v =\n  countOnesInRange v 0 (n/2) + countOnesInRange v (n/2) n",
      desc: "Partition count by ranges using Finset.card_union_of_disjoint.", difficulty: "days" },
    { id: "comparator_displacement_bound", file: "AKS/Tree/Sorting.lean", line: 2196, status: "proved", kind: "lemma",
      sig: "comparator_displacement_bound :\n  #{i | c.apply v i ≠ v i} ≤ 2",
      desc: "Comparators change at most 2 positions (subset reasoning).", difficulty: "days" },
    { id: "HasBoundedDamage", file: "AKS/Tree/Sorting.lean", line: 988, status: "definition", kind: "def",
      sig: "HasBoundedDamage (net : ComparatorNetwork n) (ε : ℝ) : Prop",
      desc: "Bounded-damage property: network increases elements at distance ≥ r by at most ε · (elements at distance ≥ r-2). Key interface between halver world and tree-sorting world.", difficulty: "done" },
    { id: "recursiveNearsort", file: "AKS/Tree/Sorting.lean", line: 2014, status: "definition", kind: "def",
      sig: "recursiveNearsort (n : ℕ)\n  (halvers : (m : ℕ) → ComparatorNetwork (2 * m))\n  (depth : ℕ) : ComparatorNetwork n",
      desc: "Recursive ε-nearsort from AKS Section 4. Applies halvers at each tree level (coarsest to finest) via applyHalversAtLevel." },
    { id: "recursiveNearsortParity", file: "AKS/Tree/Sorting.lean", line: 2028, status: "definition", kind: "def",
      sig: "recursiveNearsortParity (n : ℕ)\n  (halvers : (m : ℕ) → ComparatorNetwork (2 * m))\n  (depth parity : ℕ) : ComparatorNetwork n",
      desc: "Parity-restricted recursive nearsort: zig (parity=0, even levels) and zag (parity=1, odd levels). AKS Section 6 decomposition." },
    { id: "HasImprovedBound", file: "AKS/Tree/Sorting.lean", line: 1206, status: "definition", kind: "def",
      sig: "HasImprovedBound (net : ComparatorNetwork n) (ε : ℝ) (t : ℕ) : Prop",
      desc: "Like HasBoundedTreeDamage but with r+1 shift: elements at tree-dist ≥ r after ≤ elements at dist ≥ r+1 before + ε·error. The identity does NOT satisfy this — requires actual nearsort improvement." },
    { id: "parity_nearsort_has_bounded_tree_damage", file: "AKS/Tree/DamageStability.lean", line: 31, status: "sorry", kind: "lemma",
      sig: "parity_nearsort_has_bounded_tree_damage :\n  (∀ m, IsEpsilonHalver (halvers m) ε) →\n  HasBoundedTreeDamage (recursiveNearsortParity n halvers depth parity) ε t",
      desc: "Lemma 2a (AKS Section 8): parity-restricted nearsort → bounded tree damage (stability). Holds for both even and odd parities.", difficulty: "weeks" },
    { id: "parity_nearsort_has_improved_bound", file: "AKS/Tree/DamageImprovement.lean", line: 38, status: "sorry", kind: "lemma",
      sig: "parity_nearsort_has_improved_bound :\n  (∀ m, IsEpsilonHalver (halvers m) ε) →\n  HasImprovedBound (recursiveNearsortParity n halvers depth 0) ε t",
      desc: "Lemma 2b (AKS Section 8): even-level nearsort → HasImprovedBound (cherry-parity improvement). The key construction-specific lemma.", difficulty: "weeks" },
    { id: "bounded_tree_damage_pair_gives_zigzag", file: "AKS/Tree/Sorting.lean", line: 1258, status: "proved", kind: "lemma",
      sig: "bounded_tree_damage_pair_gives_zigzag :\n  HasImprovedBound zig ε t → HasBoundedTreeDamage zig ε t →\n  HasBoundedTreeDamage zag ε t → HasBoundedZigzagDamage zig zag ε t",
      desc: "Lemma 3 (AKS Section 8): PROVED. Algebraic — combines zig improvement + zig/zag stability, uses ε²≤ε. Previously FALSE (Phase 3e)." },

    // ── Separator/Defs.lean (Paterson/Seiferas path, parallel to Tree/) ──
    { id: "SepInitial", file: "AKS/Separator/Defs.lean", line: 29, status: "definition", kind: "def",
      sig: "SepInitial {α : Type*} [Fintype α] [LinearOrder α]\n  (w : α → α) (γ ε : ℝ) : Prop",
      desc: "ε-approximate γ-separation, initial direction (Seiferas 2009, Section 6). For each γ' ≤ γ, at most ε·γ'·n of the ⌊γ'n⌋ smallest values are outside the first ⌊γn⌋ positions." },
    { id: "IsSeparator", file: "AKS/Separator/Defs.lean", line: 48, status: "definition", kind: "def",
      sig: "IsSeparator {n : ℕ} (net : ComparatorNetwork n)\n  (γ ε : ℝ) : Prop",
      desc: "Network-level (γ, ε)-separator: for every permutation input, the output satisfies ε-approximate γ-separation (both directions). For γ = 1/2, equivalent to IsEpsilonHalver." },

    // ── Separator/Family.lean ──
    { id: "SeparatorFamily", file: "AKS/Separator/Family.lean", line: 30, status: "definition", kind: "structure",
      sig: "SeparatorFamily (γ ε : ℝ) (d : ℕ)",
      desc: "Family of (γ, ε)-separator networks indexed by input size, with depth bounded by d. Analogous to HalverFamily." },

    // ── Separator/FromHalver.lean ──
    { id: "halverToSeparator", file: "AKS/Separator/FromHalver.lean", line: 29, status: "definition", kind: "def",
      sig: "halverToSeparator (n : ℕ) (family : HalverFamily ε d) (t : ℕ) : ComparatorNetwork n",
      desc: "Computable construction: iterate halver family t levels to build a separator network. Reuses halverNetwork." },
    { id: "halver_isSeparator_half", file: "AKS/Separator/FromHalver.lean", line: 86, status: "proved", kind: "theorem",
      sig: "halver_isSeparator_half (net : ComparatorNetwork n) (ε : ℝ) :\n  IsEpsilonHalver net ε → IsSeparator net (1/2) ε",
      desc: "PROVED. Base case: ε-halver is (1/2, ε)-separator (Seiferas Lemma 1 base). Bridge via ⌊(1/2)n⌋₊ = n/2 and floor monotonicity." },
    { id: "far_outsider_count_preserved", file: "AKS/Separator/FromHalver.lean", line: 763, status: "proved", kind: "lemma",
      sig: "far_outsider_count_preserved (t : ℕ) (w₁ : Fin n → Fin n) (hw₁ : Injective w₁) (k : ℕ) :\n  |{pos ≥ C : w₂(pos) < k}| = |{pos ≥ C : w₁(pos) < k}|",
      desc: "PROVED. Count of values < k at positions outside chunk 0 is preserved by halverAtLevel. Key step: within-chunk comparators preserve the chunk-0 multiset, and bijection totals force far-outsider counts to match." },
    { id: "separator_halving_step_initial", file: "AKS/Separator/FromHalver.lean", line: 1250, status: "proved", kind: "lemma",
      sig: "separator_halving_step_initial (t : ℕ) (hsep : IsSeparator net (1/2^t) ε') :\n  SepInitial (net ++ halverAtLevel).exec v (1/2^(t+1)) (ε'+ε₁)",
      desc: "PROVED. SepInitial direction of the halving step: near outsiders bounded by ε₁·a (via halver), far outsiders bounded by ε'·γ'·n (via inductive hypothesis). Total: (ε'+ε₁)·γ'·n." },
    { id: "separator_halving_step_final", file: "AKS/Separator/FromHalver.lean", line: 1113, status: "proved", kind: "lemma",
      sig: "separator_halving_step_final (t : ℕ) (hsep : IsSeparator net (1/2^t) ε') :\n  SepFinal (net ++ halverAtLevel).exec v (1/2^(t+1)) (ε'+ε₁)",
      desc: "PROVED. SepFinal direction of the halving step: symmetric to SepInitial via order dual. Uses halverAtLevel_local_eq_last + offset bijection to reduce to halver ε-bound on last chunk." },
    { id: "separator_halving_step", file: "AKS/Separator/FromHalver.lean", line: 1365, status: "proved", kind: "theorem",
      sig: "separator_halving_step (t : ℕ) (h_even : 2 ∣ n/2^t) (h_pow_div : 2^t ∣ n) :\n  IsSeparator net (1/2^t) ε' → IsSeparator (net ++ halverAtLevel) (1/2^(t+1)) (ε'+ε₁)",
      desc: "PROVED. Induction step: halving refines (1/2^t, ε')-separation to (1/2^(t+1), ε'+ε₁)-separation. Both SepInitial and SepFinal directions proved via offset bijections + halver ε-bound." },
    { id: "halverToSeparator_isSeparator", file: "AKS/Separator/FromHalver.lean", line: 1427, status: "proved", kind: "theorem",
      sig: "halverToSeparator_isSeparator (h_div : 2^t ∣ n) :\n  IsSeparator (halverToSeparator n family t) (1/2^t) (t*ε)",
      desc: "PROVED. Induction on t: base case (empty network at γ=1) + step via separator_halving_step. t levels of iterated ε-halving give (tε)-approximate (1/2^t)-separation (Seiferas Section 6, Lemma 1)." },
    { id: "halverToSeparator_props", file: "AKS/Separator/FromHalver.lean", line: 1517, status: "sorry", kind: "theorem",
      sig: "halverToSeparator_props (n t : ℕ) (h_div : 2^t ∣ n) :\n  IsSeparator ... (1/2^t) (t*ε) ∧ depth ≤ t*d",
      desc: "Bundle separator+depth properties for halver-to-separator construction. Requires divisibility 2^t | n." },

    // ── Bags/Defs.lean ──
    { id: "bagSize", file: "AKS/Bags/Defs.lean", line: 27, status: "definition", kind: "def",
      sig: "bagSize (n level : ℕ) : ℕ",
      desc: "Size of each bag's native interval at level: n / 2^level. At root: n, at leaves: 2." },
    { id: "nativeBagIdx", file: "AKS/Bags/Defs.lean", line: 31, status: "definition", kind: "def",
      sig: "nativeBagIdx (n level : ℕ) (r : ℕ) : ℕ",
      desc: "Bag index native to rank r at given level: r / bagSize. Maps sorted ranks to bag tree positions." },
    { id: "isJStranger", file: "AKS/Bags/Defs.lean", line: 54, status: "definition", kind: "def",
      sig: "isJStranger (n rank level idx j : ℕ) : Prop",
      desc: "Item is j-strange at bag (level, idx) if native path diverges at level-(j-1) (shifted/Seiferas convention). j=1: not native to this bag." },
    { id: "jStrangerCount", file: "AKS/Bags/Defs.lean", line: 60, status: "definition", kind: "def",
      sig: "jStrangerCount (n : ℕ) (perm : Fin n → Fin n)\n  (regs : Finset (Fin n)) (level idx j : ℕ) : ℕ",
      desc: "Count of j-strangers among items in a bag. Key measure for the Seiferas invariant." },
    { id: "isJStranger_antitone", file: "AKS/Bags/Defs.lean", line: 115, status: "proved", kind: "theorem",
      sig: "isJStranger_antitone : isJStranger n rank level idx (j+1) →\n  isJStranger n rank level idx j",
      desc: "(j+1)-strange implies j-strange: divergence propagates via nativeBagIdx_div_two and div_pow_pred_div_two. Requires n power of 2 and 2^level ≤ n." },

    // ── Bags/Invariant.lean ──
    { id: "SeifInvariant", file: "AKS/Bags/Invariant.lean", line: 95, status: "definition", kind: "structure",
      sig: "SeifInvariant (n : ℕ) (A ν lam ε : ℝ) (t : ℕ)\n  (perm : Fin n → Fin n) (bags : BagAssignment n) : Prop",
      desc: "Seiferas four-clause invariant: (1) alternating empty, (2) uniform size, (3) capacity ≤ n·ν^t·A^level, (4) j-strangers ≤ lam·ε^(j-1)·capacity." },
    { id: "initialInvariant", file: "AKS/Bags/Invariant.lean", line: 186, status: "proved", kind: "theorem",
      sig: "initialInvariant (n : ℕ) (A ν lam ε : ℝ) (perm : Fin n → Fin n) :\n  SeifInvariant n A ν lam ε 0 perm (initialBags n)",
      desc: "PROVED. Initial invariant holds at t=0: all items in root, zero strangers. Direct from definitions." },
    { id: "capacity_maintained", file: "AKS/Bags/Invariant.lean", line: 296, status: "proved", kind: "theorem",
      sig: "capacity_maintained : SatisfiesC3 A ν lam → ... →\n  (rebag split level idx).card ≤ bagCapacity n A ν (t+1) level",
      desc: "PROVED. Clause (3) capacity maintained via rebag + C3 arithmetic. Defines SplitResult/rebag to make bags' concrete." },
    { id: "stranger_bound_maintained_gt1", file: "AKS/Bags/Invariant.lean", line: 435, status: "proved", kind: "theorem",
      sig: "stranger_bound_maintained_gt1 : SatisfiesC4_gt1 A ν ε → j ≥ 2 →\n  jStrangerCount ≤ lam·ε^(j-1)·bagCapacity(t+1)",
      desc: "PROVED. Clause (4) j≥2 via rebag_strangerCount_le + stranger_gt1_arithmetic + C4." },
    { id: "stranger_bound_maintained_eq1", file: "AKS/Bags/Invariant.lean", line: 511, status: "proved", kind: "theorem",
      sig: "stranger_bound_maintained_eq1 : SatisfiesC4_eq1 A ν lam ε →\n  jStrangerCount ... 1 ≤ lam·bagCapacity(t+1)",
      desc: "PROVED. Clause (4) j=1 via rebag_strangerCount_le + stranger_eq1_arithmetic + C4_eq1. Takes explicit hkick_stranger and hparent_1stranger hypotheses." },
    { id: "parent_1stranger_bound", file: "AKS/Bags/Invariant.lean", line: 594, status: "proved", kind: "theorem",
      sig: "parent_1stranger_bound :\n  jStrangerCount (fromParent ...) 1 ≤ parentStrangerCoeff·bagCapacity",
      desc: "PROVED. Parent 1-stranger bound via decomposition into 2-strangers + sibling-native items, using parentStrangerCoeff_mul_A identity." },
    { id: "invariant_maintained", file: "AKS/Bags/Invariant.lean", line: 683, status: "proved", kind: "theorem",
      sig: "invariant_maintained : SeifInvariant ... t ... →\n  SeifInvariant ... (t+1) ...",
      desc: "Full invariant maintained after one stage. Assembles all clause maintenance sublemmas (proved)." },

    // ── Bags/Split.lean ──
    { id: "rankInBag", file: "AKS/Bags/Split.lean", line: 22, status: "definition", kind: "def",
      sig: "rankInBag (perm : Fin n → Fin n) (regs : Finset (Fin n)) (i : Fin n) : ℕ",
      desc: "Rank of register i among bag items, ordered by perm value. Counts items with strictly smaller perm value." },
    { id: "rankInBag_lt_card", file: "AKS/Bags/Split.lean", line: 27, status: "proved", kind: "theorem",
      sig: "rankInBag_lt_card : i ∈ regs → rankInBag perm regs i < regs.card",
      desc: "PROVED. Rank of any item is strictly less than bag size. Via erase + card inequality." },
    { id: "rankInBag_injOn", file: "AKS/Bags/Split.lean", line: 58, status: "proved", kind: "theorem",
      sig: "rankInBag_injOn : Function.Injective perm → Set.InjOn (rankInBag perm regs) ↑regs",
      desc: "PROVED. Rank is injective on regs when perm is injective. Via strict monotonicity contradiction." },
    { id: "fringeSize", file: "AKS/Bags/Split.lean", line: 72, status: "definition", kind: "def",
      sig: "fringeSize (lam : ℝ) (b : ℕ) : ℕ",
      desc: "Fringe size: ⌊λ·b⌋ items kicked to parent from each end of the rank ordering." },
    { id: "childSendSize", file: "AKS/Bags/Split.lean", line: 75, status: "definition", kind: "def",
      sig: "childSendSize (lam : ℝ) (b : ℕ) : ℕ",
      desc: "Number of items sent to each child bag: b/2 - fringeSize. Middle portion after fringe removal." },
    { id: "concreteSplit", file: "AKS/Bags/Split.lean", line: 86, status: "definition", kind: "def",
      sig: "concreteSplit (lam : ℝ) (perm : Fin n → Fin n)\n  (bags : BagAssignment n) (level idx : ℕ) : SplitResult n",
      desc: "Concrete position-based split (Seiferas 2009 §7). Fringe → parent, middle-left → left child, middle-right → right child. Leaf levels get empty children." },
    { id: "concreteSplit_hsplit_sub", file: "AKS/Bags/Split.lean", line: 103, status: "proved", kind: "theorem",
      sig: "concreteSplit_hsplit_sub : ∀ l i,\n  toParent ⊆ bags l i ∧ toLeftChild ⊆ bags l i ∧ toRightChild ⊆ bags l i",
      desc: "PROVED. All split components are subsets of the original bag. Direct from filter_subset." },
    { id: "concreteSplit_hsplit_leaf", file: "AKS/Bags/Split.lean", line: 115, status: "proved", kind: "theorem",
      sig: "concreteSplit_hsplit_leaf : maxLevel n ≤ l →\n  toLeftChild = ∅ ∧ toRightChild = ∅",
      desc: "PROVED. At leaf levels, children components are empty. Direct from if_pos." },

    // ── Bags/SplitCard.lean ──
    { id: "filter_rankInBag_Ico_card_le", file: "AKS/Bags/SplitCard.lean", line: 24, status: "proved", kind: "theorem",
      sig: "filter_rankInBag_Ico_card_le : Function.Injective perm →\n  (regs.filter (rank ∈ [a,b))).card ≤ b - a",
      desc: "PROVED. Items with rank in [a,b) number at most b-a. Via injOn + card_le_card_of_injOn into Finset.Ico." },
    { id: "concreteSplit_toParent_card_le", file: "AKS/Bags/SplitCard.lean", line: 65, status: "proved", kind: "theorem",
      sig: "concreteSplit_toParent_card_le :\n  toParent.card ≤ 2 * fringeSize lam b + 1",
      desc: "PROVED. Parent kick has at most 2·fringeSize + 1 items. Via union bound on low-rank and high-rank filters." },
    { id: "concreteSplit_hkick", file: "AKS/Bags/SplitCard.lean", line: 149, status: "proved", kind: "theorem",
      sig: "concreteSplit_hkick : SeifInvariant ... →\n  toParent.card ≤ 2·lam·bagCapacity + 1",
      desc: "PROVED. Parent kick bounded by 2λ·capacity + 1. Bridges toParent_card_le with fringeSize_le_mul and invariant capacity bound." },
    { id: "concreteSplit_hsend_left", file: "AKS/Bags/SplitCard.lean", line: 170, status: "proved", kind: "theorem",
      sig: "concreteSplit_hsend_left : SeifInvariant ... →\n  toLeftChild.card ≤ bagCapacity / 2",
      desc: "PROVED. Left child send bounded by capacity/2. Via childSendSize_le_half and invariant capacity bound." },
    { id: "concreteSplit_hsend_right", file: "AKS/Bags/SplitCard.lean", line: 186, status: "proved", kind: "theorem",
      sig: "concreteSplit_hsend_right : SeifInvariant ... →\n  toRightChild.card ≤ bagCapacity / 2",
      desc: "PROVED. Right child send bounded by capacity/2. Via childSendSize_le_half and invariant capacity bound." },
    { id: "concreteSplit_hkick_pair", file: "AKS/Bags/SplitCard.lean", line: 205, status: "sorry", kind: "theorem",
      sig: "concreteSplit_hkick_pair : bagCapacity < A →\n  paired kick ≤ 4·lam·bagCapacity",
      desc: "Paired kick from both children has no +2 additive term when cap < A. Requires even bag sizes at child level." },
    { id: "concreteSplit_hrebag_uniform", file: "AKS/Bags/SplitCard.lean", line: 216, status: "sorry", kind: "theorem",
      sig: "concreteSplit_hrebag_uniform :\n  (rebag ... level i₁).card = (rebag ... level i₂).card",
      desc: "All bags at a given level have equal size after rebagging with the concrete split." },
    { id: "concreteSplit_hrebag_disjoint", file: "AKS/Bags/SplitCard.lean", line: 225, status: "sorry", kind: "theorem",
      sig: "concreteSplit_hrebag_disjoint : (l₁,i₁) ≠ (l₂,i₂) →\n  Disjoint (rebag ...) (rebag ...)",
      desc: "Bags at distinct positions are disjoint after rebagging with the concrete split." },

    // ── Bags/Stage.lean ──
    { id: "separatorStage", file: "AKS/Bags/Stage.lean", line: 53, status: "definition", kind: "def",
      sig: "separatorStage (n : ℕ) (sep : SeparatorFamily gam eps d_sep)\n  (stageIdx : ℕ) : ComparatorNetwork n",
      desc: "One stage: apply separator to all active bags in parallel. Active bags have disjoint registers." },
    { id: "active_bags_disjoint", file: "AKS/Bags/Stage.lean", line: 35, status: "proved", kind: "theorem",
      sig: "active_bags_disjoint : (l₁,i₁) ≠ (l₂,i₂) →\n  Disjoint (bags l₁ i₁) (bags l₂ i₂)",
      desc: "Active bags have disjoint registers. Follows from bags_disjoint clause in SeifInvariant." },
    { id: "separatorStage_depth_le", file: "AKS/Bags/Stage.lean", line: 66, status: "proved", kind: "theorem",
      sig: "separatorStage_depth_le :\n  (separatorStage n sep t).depth ≤ d_sep",
      desc: "One stage depth = separator depth, since all bags run in parallel (disjoint wires)." },

    // ── Bags/TreeSort.lean ──
    { id: "separatorSortingNetwork", file: "AKS/Bags/TreeSort.lean", line: 26, status: "definition", kind: "def",
      sig: "separatorSortingNetwork (n : ℕ) (sep : SeparatorFamily gam eps d_sep)\n  (numStages : ℕ) : ComparatorNetwork n",
      desc: "Full separator sorting network: concatenate numStages stages. Computable construction." },
    { id: "separatorSortingNetwork_depth_le", file: "AKS/Bags/TreeSort.lean", line: 35, status: "proved", kind: "theorem",
      sig: "separatorSortingNetwork_depth_le :\n  depth ≤ numStages * d_sep",
      desc: "Total depth ≤ numStages × separator depth. From per-stage depth bound (placeholder stages have 0 depth)." },
    { id: "separatorSortingNetwork_converges", file: "AKS/Bags/TreeSort.lean", line: 56, status: "proved", kind: "theorem",
      sig: "separatorSortingNetwork_converges :\n  ∀ level idx, (bags level idx).card ≤ 1",
      desc: "PROVED. Convergence: when capacity < 2 at leaves, all bags have ≤ 1 item. Via capacity_mono_level + bounded_depth." },
    { id: "separatorSortingNetwork_sorts", file: "AKS/Bags/TreeSort.lean", line: 92, status: "sorry", kind: "theorem",
      sig: "separatorSortingNetwork_sorts :\n  Monotone (net.exec v)",
      desc: "Correctness: separator sorting network sorts all Boolean inputs. Via invariant convergence + zero strangers." },
    { id: "separatorSortingNetwork_depth_bound", file: "AKS/Bags/TreeSort.lean", line: 104, status: "proved", kind: "theorem",
      sig: "separatorSortingNetwork_depth_bound :\n  depth ≤ C * d_sep * Nat.log 2 n",
      desc: "PROVED. O(log n) depth bound. Direct from depth_le + numStages = C·log₂(n)." },

    // Split stranger bounds (Instance 2 of Part B)
    { id: "jStrangerCount_level_shift", file: "AKS/Bags/SplitStranger.lean", line: 39, status: "proved", kind: "theorem",
      sig: "jStrangerCount_level_shift :\n  jStrangerCount perm S (l-1) (i/2) j = jStrangerCount perm S l i (j+1)",
      desc: "PROVED. Level-shift identity: j-strangers at parent (l-1,i/2) = (j+1)-strangers at child (l,i). Pure Nat arithmetic." },
    { id: "kick_stranger_bound", file: "AKS/Bags/SplitStranger.lean", line: 68, status: "proved", kind: "theorem",
      sig: "kick_stranger_bound :\n  jStrangerCount (split l i).toParent (l-1) (i/2) j ≤ lam·ε^j·cap(l)",
      desc: "PROVED. hkick_stranger hypothesis: fringe items have few strangers at parent level. Via level shift + subset mono + invariant." },
    { id: "fromParent_stranger_filtered", file: "AKS/Bags/SplitStranger.lean", line: 120, status: "sorry", kind: "theorem",
      sig: "fromParent_stranger_filtered :\n  jStrangerCount (fromParent split l i) (l-1) (i/2) j ≤ ε·jStrangerCount bags(l-1,i/2) j",
      desc: "Separator filtering: at most ε fraction of parent's strangers leak past fringe to children. Needs SepInitial/SepFinal connection." },
    { id: "parent_stranger_bound", file: "AKS/Bags/SplitStranger.lean", line: 141, status: "sorry", kind: "theorem",
      sig: "parent_stranger_bound :\n  jStrangerCount (fromParent split l i) l i j ≤ lam·ε^(j-1)·cap(l-1)",
      desc: "hparent_stranger hypothesis (j≥2). Proof complete: level shift + filtering + invariant. Sorry from fromParent_stranger_filtered." },
    { id: "cnative_from_parent_bound", file: "AKS/Bags/SplitStranger.lean", line: 201, status: "sorry", kind: "theorem",
      sig: "cnative_from_parent_bound :\n  siblingNativeCount (fromParent split l i) l i ≤ cnativeCoeff·cap(l-1)",
      desc: "Sibling-native bound among items from parent. Three sub-sources: halving errors + geometric series + above-parent items." },
    { id: "parent_1stranger_from_inv", file: "AKS/Bags/SplitStranger.lean", line: 217, status: "sorry", kind: "theorem",
      sig: "parent_1stranger_from_inv :\n  jStrangerCount (fromParent split l i) l i 1 ≤ parentStrangerCoeff·cap(l)",
      desc: "hparent_1stranger hypothesis. Assembly proved: level shift + filtering + invariant + parent_1stranger_bound. Sorry from sub-lemmas." },

    // V2 tree-distance-based definitions (Phase 1 of targeted hybrid)
    { id: "sectionIndex", file: "AKS/Tree/Sorting.lean", line: 840, status: "definition", kind: "def",
      sig: "sectionIndex (n t i : ℕ) : ℕ",
      desc: "Section index at level t for position i: ⌊i·2^t/n⌋. Maps positions to binary tree sections." },
    { id: "sectionNode", file: "AKS/Tree/Sorting.lean", line: 865, status: "definition", kind: "def",
      sig: "sectionNode (n t : ℕ) (i : Fin n) : TreeNode",
      desc: "TreeNode at level t for position i. Maps each position to its section in the binary tree." },
    { id: "positionTreeDist", file: "AKS/Tree/Sorting.lean", line: 1020, status: "definition", kind: "def",
      sig: "positionTreeDist (n t : ℕ) (v : Fin n → Bool) (i : Fin n) : ℕ",
      desc: "Tree displacement of position i: tree distance from i's section to threshold section at level t." },
    { id: "elementsAtTreeDist", file: "AKS/Tree/Sorting.lean", line: 1099, status: "definition", kind: "def",
      sig: "elementsAtTreeDist (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : Finset (Fin n)",
      desc: "Elements in J displaced at tree-distance ≥ r. Time-dependent V2 of elementsAtDistance." },
    { id: "HasBoundedTreeDamage", file: "AKS/Tree/Sorting.lean", line: 1191, status: "definition", kind: "def",
      sig: "HasBoundedTreeDamage (net : ComparatorNetwork n) (ε : ℝ) (t : ℕ) : Prop",
      desc: "V2 bounded-damage using tree distance. Network increases tree-dist count by ≤ ε·count(r-2)." },
    { id: "treeWrongnessV2", file: "AKS/Tree/Sorting.lean", line: 1752, status: "definition", kind: "def",
      sig: "treeWrongnessV2 (n t : ℕ) (v : Fin n → Bool) (J : Interval n) (r : ℕ) : ℝ",
      desc: "V2 tree wrongness using elementsAtTreeDist. Genuinely time-dependent (depends on t via sectionNode)." },
    { id: "cherry_wrongness_after_nearsort_v2", file: "AKS/Tree/Sorting.lean", line: 2494, status: "sorry", kind: "lemma",
      sig: "cherry_wrongness_after_nearsort_v2 :\n  treeWrongnessV2 (net.exec v) J r ≤ treeWrongnessV2 v J r + ε·treeWrongnessV2 v J (r-2)",
      desc: "V2: Cherry wrongness after nearsort. Needs bridge between Bool-based treeWrongnessV2 and permutation-based HasBoundedTreeDamage." },
    { id: "zig_step_bounded_increase_v2", file: "AKS/Tree/Sorting.lean", line: 2576, status: "sorry", kind: "lemma",
      sig: "zig_step_bounded_increase_v2 :\n  treeWrongnessV2 v' J r ≤ 8·A·(treeWrongnessV2 v J r + ε·treeWrongnessV2 v J (r-2))",
      desc: "V2: Zig step bounded increase. Needs bridge between Bool-based treeWrongnessV2 and permutation-based HasBoundedTreeDamage." },
    { id: "positionTreeDist_succ_le", file: "AKS/Tree/Sorting.lean", line: 1039, status: "proved", kind: "lemma",
      sig: "positionTreeDist_succ_le :\n  positionTreeDist n (t+1) v i ≤ positionTreeDist n t v i + 2",
      desc: "Tree distance increases by at most 2 when refining from level t to t+1. Uses sectionIndex_succ_div_two and indexAtLevel agreement." },
    { id: "HasBoundedZigzagDamage", file: "AKS/Tree/Sorting.lean", line: 1233, status: "definition", kind: "definition",
      sig: "HasBoundedZigzagDamage zig_net zag_net ε t : Prop",
      desc: "Combined zigzag bounded-damage with r → r+1 distance shift. Key structural property of even/odd cherry alternation." },
    { id: "register_reassignment_increases_wrongness_v2", file: "AKS/Tree/Sorting.lean", line: 2524, status: "proved", kind: "lemma",
      sig: "register_reassignment_increases_wrongness_v2 :\n  treeWrongnessV2 (t+1) v J' r ≤ C · treeWrongnessV2 t v J (r-2)",
      desc: "V2 Lemma 1: Register reassignment. Single v, J'⊆J, distance shift 2, parameterized constant C." },
    { id: "zigzag_decreases_wrongness_v2", file: "AKS/Tree/Sorting.lean", line: 2610, status: "sorry", kind: "lemma",
      sig: "zigzag_decreases_wrongness_v2 :\n  treeWrongnessV2 t v'' J r ≤ treeWrongnessV2 t v J (r+1) + 3ε·tw(r-4)",
      desc: "V2 Lemma 3: ZigZag combined step. Needs bridge between Bool-based treeWrongnessV2 and permutation-based HasBoundedZigzagDamage." },
    { id: "aks_tree_sorting", file: "AKS/Tree/AKSNetwork.lean", line: 143, status: "sorry", kind: "theorem", milestone: true,
      sig: "aks_tree_sorting (ε : ℝ) (d : ℕ) (hε : 0 < ε) (hε1 : ε < 1/2)\n  (family : HalverFamily ε d) :\n  ∃ net, net.size ≤ 200·(d+1)·n·log₂ n ∧ ∀ v, Monotone (net.exec v)",
      desc: "Main theorem: HalverFamily → O(n log n) sorting network. Uses recursiveNearsort with multi-level halvers.", difficulty: "months" }
  ],

  // Edges: [source, target] means "target depends on source" (arrow points from source to target)
  edges: [
    // RegularGraph foundations
    ["RegularGraph", "walkCLM"],
    ["RegularGraph", "meanCLM"],
    ["walkCLM", "spectralGap"],
    ["meanCLM", "spectralGap"],
    ["spectralGap", "spectralGap_nonneg"],
    ["spectralGap", "spectralGap_le_one"],
    ["walkCLM", "spectralGap_le_one"],
    ["meanCLM", "spectralGap_le_one"],

    // Mean projection properties
    ["meanCLM", "meanCLM_idempotent"],
    ["meanCLM", "meanCLM_isSelfAdjoint"],

    // Square
    ["RegularGraph", "RegularGraph.square"],
    ["spectralGap", "spectralGap_square"],
    ["RegularGraph.square", "spectralGap_square"],
    ["walkCLM", "spectralGap_square"],
    ["meanCLM", "spectralGap_square"],
    ["meanCLM_idempotent", "spectralGap_square"],
    ["meanCLM_isSelfAdjoint", "spectralGap_square"],

    // Complete graph
    ["RegularGraph", "completeGraph"],
    ["spectralGap", "spectralGap_complete"],
    ["completeGraph", "spectralGap_complete"],

    // Mixing lemma
    ["spectralGap", "expander_mixing_lemma"],
    ["walkCLM", "expander_mixing_lemma"],
    ["indicatorVec", "expander_mixing_lemma"],
    ["RegularGraph", "expander_mixing_lemma"],

    // Sorting network basics
    ["Comparator", "ComparatorNetwork"],
    ["ComparatorNetwork", "IsSortingNetwork"],
    ["ComparatorNetwork", "zero_one_principle"],
    ["IsSortingNetwork", "zero_one_principle"],

    // Halver theory
    ["ComparatorNetwork", "IsEpsilonHalver"],
    ["RegularGraph", "tanner_bound"],
    ["spectralGap", "tanner_bound"],
    ["expander_mixing_lemma", "tanner_bound"],
    ["tanner_bound", "expanderHalver_isEpsilonHalver"],
    ["IsEpsilonHalver", "expanderHalver_isEpsilonHalver"],
    ["expanderHalver", "expanderHalver_isEpsilonHalver"],
    ["expanderHalver", "expanderHalver_size"],
    ["RegBipartite", "hall_condition"],
    ["hall_condition", "konigMatchings_bijective"],
    ["RegBipartite", "konigMatchings_bijective"],
    ["konigMatchings_bijective", "exists_halver_depth_le"],
    ["expanderHalver_isEpsilonHalver", "exists_halver_depth_le"],
    ["expanderHalver_size", "exists_halver_depth_le"],
    ["IsEpsilonHalver", "HalverFamily"],
    ["ComparatorNetwork", "HalverFamily"],
    ["HalverFamily", "HalverFamily.size_le"],
    ["size_le_half_n_mul_depth", "HalverFamily.size_le"],
    ["exists_halver_depth_le", "expanderHalverFamily"],
    ["HalverFamily", "expanderHalverFamily"],
    ["IsEpsilonHalver", "epsHalverMerge"],
    ["ComparatorNetwork", "epsHalverMerge"],
    ["IsEpsilonSorted", "Monotone.bool_pattern"],
    // Edges to deleted nodes (wrongness, halver_composition, etc.) removed

    // Comparator network injectivity and shiftEmbed
    ["Comparator", "Comparator.apply_injective"],
    ["Comparator.apply_injective", "exec_injective"],
    ["ComparatorNetwork", "exec_injective"],
    ["ComparatorNetwork", "shiftEmbed_exec_outside"],

    // Nearsort/ — halver family → nearsort
    ["IsEpsilonHalver", "farSmallCount_depth_bound"],
    ["IsEpsilonHalver", "farLargeCount_depth_bound"],
    ["farSmallCount_depth_bound", "halverNetwork_initialNearsorted"],
    ["farLargeCount_depth_bound", "halverNetwork_finalNearsorted"],
    ["exec_injective", "halverNetwork_initialNearsorted"],
    ["exec_injective", "halverNetwork_finalNearsorted"],
    ["rank_fin_val", "halverNetwork_initialNearsorted"],
    ["rank_fin_val", "halverNetwork_finalNearsorted"],
    ["halverAtLevel_size", "halverNetwork_size"],
    ["halverNetwork_initialNearsorted", "halver_family_gives_nearsort"],
    ["halverNetwork_finalNearsorted", "halver_family_gives_nearsort"],
    ["halverNetwork_size", "halver_family_gives_nearsort"],

    // Zig-zag operators
    ["RegularGraph", "RegularGraph.zigzag"],
    ["walkCLM", "withinClusterCLM"],
    ["RegularGraph", "stepPermCLM"],
    ["meanCLM", "clusterMeanCLM"],
    ["Fin.pair_lt", "withinClusterCLM"],
    ["Fin.pair_lt", "stepPermCLM"],
    ["Fin.pair_lt", "clusterMeanCLM"],
    ["withinClusterCLM", "zigzag_walkCLM_eq"],
    ["stepPermCLM", "zigzag_walkCLM_eq"],
    ["RegularGraph.zigzag", "zigzag_walkCLM_eq"],

    // Zig-zag spectral properties
    ["clusterMeanCLM", "clusterMeanCLM_idempotent"],
    ["clusterMeanCLM", "clusterMeanCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinClusterCLM_isSelfAdjoint"],
    ["withinClusterCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "withinCluster_comp_clusterMean"],
    ["clusterMeanCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "clusterMean_comp_withinCluster"],
    ["withinClusterCLM", "withinClusterCLM_norm_le_one"],
    ["stepPermCLM", "stepPermCLM_sq_eq_one"],
    ["stepPermCLM", "stepPermCLM_isSelfAdjoint"],
    ["stepPermCLM", "stepPermCLM_comp_meanCLM"],
    ["meanCLM", "stepPermCLM_comp_meanCLM"],
    ["withinClusterCLM", "withinCluster_tilde_contraction"],
    ["clusterMeanCLM", "withinCluster_tilde_contraction"],
    ["spectralGap", "withinCluster_tilde_contraction"],
    ["stepPermCLM", "hat_block_norm"],
    ["clusterMeanCLM", "hat_block_norm"],
    ["meanCLM", "hat_block_norm"],
    ["spectralGap", "hat_block_norm"],
    ["meanCLM_eq_clusterMean_comp", "hat_block_norm"],
    ["clusterMean_comp_meanCLM", "hat_block_norm"],
    ["meanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "meanCLM_eq_clusterMean_comp"],
    ["clusterMeanCLM", "clusterMean_comp_meanCLM"],
    ["meanCLM", "clusterMean_comp_meanCLM"],

    // RVW bound
    ["rvwBound", "rvwBound_mono_left"],
    ["rvwBound", "rvwBound_mono_right"],
    ["rvwBound", "rvw_quadratic_ineq"],
    ["rvw_quadratic_ineq", "rvw_operator_norm_bound"],

    // Zig-zag assembly
    ["zigzag_walkCLM_eq", "zigzag_spectral_bound"],
    ["clusterMeanCLM_idempotent", "zigzag_spectral_bound"],
    ["clusterMeanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinClusterCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_comp_clusterMean", "zigzag_spectral_bound"],
    ["clusterMean_comp_withinCluster", "zigzag_spectral_bound"],
    ["withinClusterCLM_norm_le_one", "zigzag_spectral_bound"],
    ["stepPermCLM_sq_eq_one", "zigzag_spectral_bound"],
    ["stepPermCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["stepPermCLM_comp_meanCLM", "zigzag_spectral_bound"],
    ["meanCLM_idempotent", "zigzag_spectral_bound"],
    ["meanCLM_isSelfAdjoint", "zigzag_spectral_bound"],
    ["withinCluster_tilde_contraction", "zigzag_spectral_bound"],
    ["hat_block_norm", "zigzag_spectral_bound"],
    ["meanCLM_eq_clusterMean_comp", "zigzag_spectral_bound"],
    ["clusterMean_comp_meanCLM", "zigzag_spectral_bound"],
    ["rvw_operator_norm_bound", "zigzag_spectral_bound"],

    // Iterated construction
    ["RegularGraph.square", "zigzagFamily"],
    ["RegularGraph.zigzag", "zigzagFamily"],
    ["zigzag_spectral_bound", "zigzagFamily_gap"],
    ["spectralGap_square", "zigzagFamily_gap"],
    ["rvwBound_mono_left", "zigzagFamily_gap"],
    ["rvwBound_mono_right", "zigzagFamily_gap"],
    ["zigzagFamily", "zigzagFamily_gap"],
    ["zigzagFamily_gap", "explicit_expanders_exist_zigzag"],
    ["zigzagFamily", "explicit_expanders_exist_zigzag"],

    // Cert/FastProof
    ["certificate_bridge", "checkCertificateFast_eq_slow"],

    // Base expanders (Random16, Random1728, Random20736)
    ["RegularGraph", "Random16.graph"],
    ["certificate_bridge", "Random16.gap"],
    ["checkCertificateFast_eq_slow", "Random16.gap"],
    ["Random16.graph", "Random16.gap"],
    ["RegularGraph", "Random1728.graph"],
    ["certificate_bridge", "Random1728.gap"],
    ["checkCertificateFast_eq_slow", "Random1728.gap"],
    ["Random1728.graph", "Random1728.gap"],
    ["RegularGraph", "Random20736.graph"],
    ["certificate_bridge", "Random20736.gap"],
    ["checkCertificateFast_eq_slow", "Random20736.gap"],
    ["Random20736.graph", "Random20736.gap"],
    ["Random20736.gap", "explicit_expanders_exist_zigzag"],
    // Retired edges (for historical snapshots)
    ["RegularGraph", "baseExpander"],
    ["spectralGap", "baseExpander_gap"],
    ["baseExpander", "baseExpander_gap"],

    // Tree/AKSNetwork.lean — helper lemmas
    ["epsHalverMerge", "epsHalverMerge_exec_eq_iterate"],
    ["epsHalverMerge", "epsHalverMerge_size"],

    // Top-level parameterized theorem (Tree/AKSNetwork.lean)
    ["zero_one_principle", "zigzag_implies_aks_network"],
    ["aks_tree_sorting", "zigzag_implies_aks_network"],
    ["expanderHalverFamily", "zigzag_implies_aks_network"],

    // aks_tree_sorting depends on HalverFamily
    ["HalverFamily", "aks_tree_sorting"],

    // Tree/Sorting — edges FROM main proof chain into Tree/Sorting
    ["IsEpsilonHalver", "halver_preserves_monotone"],
    ["IsEpsilonHalver", "parity_nearsort_has_bounded_tree_damage"],
    ["IsEpsilonHalver", "parity_nearsort_has_improved_bound"],
    ["Comparator", "comparator_displacement_bound"],

    // Tree/ — internal edges
    ["TreeNode", "treeWrongness"],
    ["countOnes_le", "countOnes_split"],
    ["recursiveNearsortParity", "parity_nearsort_has_bounded_tree_damage"],
    ["recursiveNearsortParity", "parity_nearsort_has_improved_bound"],
    ["parity_nearsort_has_bounded_tree_damage", "HasBoundedTreeDamage"],
    ["parity_nearsort_has_improved_bound", "HasImprovedBound"],
    ["HasImprovedBound", "bounded_tree_damage_pair_gives_zigzag"],
    ["HasBoundedTreeDamage", "bounded_tree_damage_pair_gives_zigzag"],
    ["bounded_tree_damage_pair_gives_zigzag", "HasBoundedZigzagDamage"],

    // V2 tree-distance-based definitions
    ["TreeNode", "sectionNode"],
    ["sectionIndex", "sectionNode"],
    ["sectionNode", "positionTreeDist"],
    ["positionTreeDist", "elementsAtTreeDist"],
    ["elementsAtTreeDist", "HasBoundedTreeDamage"],
    ["elementsAtTreeDist", "treeWrongnessV2"],
    ["HasBoundedTreeDamage", "cherry_wrongness_after_nearsort_v2"],
    ["treeWrongnessV2", "cherry_wrongness_after_nearsort_v2"],
    ["HasBoundedTreeDamage", "zig_step_bounded_increase_v2"],
    ["treeWrongnessV2", "zig_step_bounded_increase_v2"],
    ["positionTreeDist", "positionTreeDist_succ_le"],
    ["positionTreeDist_succ_le", "register_reassignment_increases_wrongness_v2"],
    ["treeWrongnessV2", "register_reassignment_increases_wrongness_v2"],
    ["elementsAtTreeDist", "register_reassignment_increases_wrongness_v2"],
    ["elementsAtTreeDist", "HasBoundedZigzagDamage"],
    ["HasBoundedZigzagDamage", "zigzag_decreases_wrongness_v2"],
    ["treeWrongnessV2", "zigzag_decreases_wrongness_v2"],

    // aks_tree_sorting — depends on V2 chain
    ["register_reassignment_increases_wrongness_v2", "aks_tree_sorting"],
    ["zigzag_decreases_wrongness_v2", "aks_tree_sorting"],
    ["parity_nearsort_has_bounded_tree_damage", "aks_tree_sorting"],
    ["parity_nearsort_has_improved_bound", "aks_tree_sorting"],
    ["bounded_tree_damage_pair_gives_zigzag", "aks_tree_sorting"],

    // Main.lean — iterated squaring and final assembly
    ["spectralGap_square", "spectralGap_squareIter"],
    ["squareIter", "spectralGap_squareIter"],
    ["explicit_expanders_exist_zigzag", "expander_family_small_gap"],
    ["squareIter", "expander_family_small_gap"],
    ["spectralGap_squareIter", "expander_family_small_gap"],
    ["exists_pow_two_pow_lt", "expander_family_small_gap"],
    ["expander_family_small_gap", "aks_sorting_networks_exist"],
    ["zigzag_implies_aks_network", "aks_sorting_networks_exist"],

    // Seiferas.lean — separator-path assembly
    ["expanderHalverFamily", "expanderToHalverFamily"],
    ["HalverFamily", "halverToSeparatorFamily'"],
    ["halverToSeparator_isSeparator", "halverToSeparatorFamily'"],
    ["SeparatorFamily", "halverToSeparatorFamily'"],
    ["expanderToHalverFamily", "seiferas_implies_sorting_network"],
    ["halverToSeparatorFamily'", "seiferas_implies_sorting_network"],
    ["separatorSortingNetwork_sorts", "seiferas_implies_sorting_network"],
    ["separatorSortingNetwork_depth_le", "seiferas_implies_sorting_network"],
    ["size_le_half_n_mul_depth", "seiferas_implies_sorting_network"],
    ["zero_one_principle", "seiferas_implies_sorting_network"],
    ["seiferas_implies_sorting_network", "seiferas_sorting_networks_exist"],
    ["explicit_expanders_exist_zigzag", "seiferas_sorting_networks_exist"],

    // WalkBound
    ["spectralGap", "spectralGap_le_of_walk_bound"],
    ["walkCLM", "spectralGap_le_of_walk_bound"],

    // SpectralMatrix
    ["RegularGraph", "spectralMatrix"],
    ["spectralMatrix", "spectralMatrix_isHermitian"],
    ["spectralMatrix", "spectralMatrix_posSemidef_implies_walk_bound"],
    ["walkCLM", "spectralMatrix_posSemidef_implies_walk_bound"],
    ["meanCLM", "spectralMatrix_posSemidef_implies_walk_bound"],

    // DiagDominant (standalone, no AKS imports)

    // CertificateBridge
    ["certMatrixReal", "certMatrix_posdiag"],
    ["certMatrixReal", "kRowDominant_implies_diagDominant"],
    ["kRowDominant_implies_diagDominant", "congruence_diagDominant"],
    ["checkColumnNormBoundPure_spec", "congruence_diagDominant"],
    ["certMatrix_posdiag", "checker_implies_spectralMatrix_psd"],
    ["congruence_diagDominant", "checker_implies_spectralMatrix_psd"],
    ["diagDominant_posSemidef", "checker_implies_spectralMatrix_psd"],
    ["spectralMatrix", "checker_implies_spectralMatrix_psd"],
    ["checker_implies_spectralMatrix_psd", "certificate_implies_walk_bound"],
    ["spectralMatrix_posSemidef_implies_walk_bound", "certificate_implies_walk_bound"],
    ["certificate_implies_walk_bound", "certificate_bridge"],
    ["spectralGap_le_of_walk_bound", "certificate_bridge"],
    ["sqrt_coeff_le_frac", "certificate_bridge"],

    // Separator/Family
    ["IsSeparator", "SeparatorFamily"],

    // Separator/FromHalver
    ["HalverFamily", "halverToSeparator"],
    ["IsEpsilonHalver", "halver_isSeparator_half"],
    ["IsSeparator", "halver_isSeparator_half"],
    ["halver_isSeparator_half", "halverToSeparator_isSeparator"],
    ["separator_halving_step", "halverToSeparator_isSeparator"],
    ["IsSeparator", "separator_halving_step"],
    ["IsEpsilonHalver", "separator_halving_step"],
    ["far_outsider_count_preserved", "separator_halving_step_initial"],
    ["IsSeparator", "separator_halving_step_initial"],
    ["IsEpsilonHalver", "separator_halving_step_initial"],
    ["separator_halving_step_initial", "separator_halving_step"],
    ["separator_halving_step_final", "separator_halving_step"],
    ["IsSeparator", "separator_halving_step_final"],
    ["IsEpsilonHalver", "separator_halving_step_final"],
    ["halverToSeparator", "halverToSeparator_props"],
    ["halverToSeparator_isSeparator", "halverToSeparator_props"],
    ["SeparatorFamily", "halverToSeparator_props"],

    // Bags/Defs
    ["bagSize", "nativeBagIdx"],
    ["nativeBagIdx", "isJStranger"],
    ["isJStranger", "jStrangerCount"],
    ["isJStranger", "isJStranger_antitone"],

    // Bags/Invariant
    ["jStrangerCount", "SeifInvariant"],
    ["SeifInvariant", "initialInvariant"],
    ["SeifInvariant", "capacity_maintained"],
    ["SeifInvariant", "stranger_bound_maintained_gt1"],
    ["SeifInvariant", "stranger_bound_maintained_eq1"],
    ["capacity_maintained", "invariant_maintained"],
    ["stranger_bound_maintained_gt1", "invariant_maintained"],
    ["stranger_bound_maintained_eq1", "invariant_maintained"],
    ["parent_1stranger_bound", "stranger_bound_maintained_eq1"],
    ["parent_1stranger_bound", "invariant_maintained"],

    // Bags/Split
    ["rankInBag", "rankInBag_lt_card"],
    ["rankInBag", "rankInBag_injOn"],
    ["rankInBag", "concreteSplit"],
    ["fringeSize", "concreteSplit"],
    ["childSendSize", "concreteSplit"],
    ["concreteSplit", "concreteSplit_hsplit_sub"],
    ["concreteSplit", "concreteSplit_hsplit_leaf"],

    // Bags/SplitCard
    ["rankInBag_injOn", "filter_rankInBag_Ico_card_le"],
    ["filter_rankInBag_Ico_card_le", "concreteSplit_toParent_card_le"],
    ["concreteSplit", "concreteSplit_toParent_card_le"],
    ["concreteSplit_toParent_card_le", "concreteSplit_hkick"],
    ["SeifInvariant", "concreteSplit_hkick"],
    ["concreteSplit", "concreteSplit_hsend_left"],
    ["SeifInvariant", "concreteSplit_hsend_left"],
    ["concreteSplit", "concreteSplit_hsend_right"],
    ["SeifInvariant", "concreteSplit_hsend_right"],
    ["concreteSplit_hkick", "concreteSplit_hkick_pair"],
    ["SeifInvariant", "concreteSplit_hkick_pair"],
    ["concreteSplit", "concreteSplit_hrebag_uniform"],
    ["concreteSplit", "concreteSplit_hrebag_disjoint"],

    // Bags/Stage
    ["SeparatorFamily", "separatorStage"],
    ["SeifInvariant", "active_bags_disjoint"],
    ["active_bags_disjoint", "separatorStage_depth_le"],
    ["separatorStage", "separatorStage_depth_le"],

    // Bags/TreeSort
    ["separatorStage", "separatorSortingNetwork"],
    ["separatorStage_depth_le", "separatorSortingNetwork_depth_le"],
    ["separatorSortingNetwork", "separatorSortingNetwork_depth_le"],
    ["separatorSortingNetwork", "separatorSortingNetwork_sorts"],
    ["invariant_maintained", "separatorSortingNetwork_sorts"],
    ["separatorSortingNetwork_depth_le", "separatorSortingNetwork_depth_bound"]
  ],

  // File groupings with display names
  groups: [
    { id: "AKS/Misc/Fin.lean", label: "Misc/Fin.lean", color: "#1a1e24" },
    { id: "AKS/Graph/Regular.lean", label: "Graph/Regular.lean", color: "#1a1e24" },
    { id: "AKS/Graph/Square.lean", label: "Graph/Square.lean", color: "#1a1e24" },
    { id: "AKS/Graph/Complete.lean", label: "Graph/Complete.lean", color: "#1a1e24" },
    { id: "AKS/Halver/Mixing.lean", label: "Halver/Mixing.lean", color: "#1a1e24" },
    { id: "AKS/Sort/Defs.lean", label: "Sort/Defs.lean", color: "#1a1e24" },
    { id: "AKS/Sort/Monotone.lean", label: "Sort/Monotone.lean", color: "#1a1e24" },
    { id: "AKS/Sort/ZeroOne.lean", label: "Sort/ZeroOne.lean", color: "#1a1e24" },
    { id: "AKS/Sort/Depth.lean", label: "Sort/Depth.lean", color: "#1a1e24" },
    { id: "AKS/Tree/AKSNetwork.lean", label: "Tree/AKSNetwork.lean", color: "#1a1e24" },
    { id: "AKS/Halver/Defs.lean", label: "Halver/Defs.lean", color: "#1a1e24" },
    { id: "AKS/Nearsort/Construction.lean", label: "Nearsort/Construction.lean", color: "#1a1e24" },
    { id: "AKS/Nearsort/Correctness.lean", label: "Nearsort/Correctness.lean", color: "#1a1e24" },
    { id: "AKS/Nearsort/HalverToNearsort.lean", label: "Nearsort/HalverToNearsort.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag/Operators.lean", label: "ZigZagOperators.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag/Spectral.lean", label: "ZigZagSpectral.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag/RVWBound.lean", label: "RVWBound.lean", color: "#1a1e24" },
    { id: "AKS/ZigZag/Expanders.lean", label: "ZigZag/Expanders.lean", color: "#1a1e24" },
    { id: "AKS/Cert/WalkBound.lean", label: "WalkBound.lean", color: "#1a1e24" },
    { id: "AKS/Cert/SpectralMatrix.lean", label: "SpectralMatrix.lean", color: "#1a1e24" },
    { id: "AKS/Cert/DiagDominant.lean", label: "DiagDominant.lean", color: "#1a1e24" },
    { id: "AKS/Cert/Bridge.lean", label: "Cert/Bridge.lean", color: "#1a1e24" },
    { id: "AKS/Cert/FastProof.lean", label: "Cert/FastProof.lean", color: "#1a1e24" },
    { id: "AKS/Random/Random16.lean", label: "Random/Random16.lean", color: "#1a1e24" },
    { id: "AKS/Random/Random1728.lean", label: "Random/Random1728.lean", color: "#1a1e24" },
    { id: "AKS/Random/Random20736.lean", label: "Random/Random20736.lean", color: "#1a1e24" },
    { id: "AKS/Tree/Sorting.lean", label: "Tree/Sorting.lean", color: "#1a1e24" },
    { id: "AKS/Tree/DamageStability.lean", label: "Tree/DamageStability.lean", color: "#1a1e24" },
    { id: "AKS/Tree/DamageImprovement.lean", label: "Tree/DamageImprovement.lean", color: "#1a1e24" },
    { id: "AKS/Separator/Defs.lean", label: "Separator/Defs.lean", color: "#1a1e24" },
    { id: "AKS/Separator/Family.lean", label: "Separator/Family.lean", color: "#1a1e24" },
    { id: "AKS/Separator/FromHalver.lean", label: "Separator/FromHalver.lean", color: "#1a1e24" },
    { id: "AKS/Bags/Defs.lean", label: "Bags/Defs.lean", color: "#1a1e24" },
    { id: "AKS/Bags/Invariant.lean", label: "Bags/Invariant.lean", color: "#1a1e24" },
    { id: "AKS/Bags/Split.lean", label: "Bags/Split.lean", color: "#1a1e24" },
    { id: "AKS/Bags/SplitCard.lean", label: "Bags/SplitCard.lean", color: "#1a1e24" },
    { id: "AKS/Bags/Stage.lean", label: "Bags/Stage.lean", color: "#1a1e24" },
    { id: "AKS/Bags/TreeSort.lean", label: "Bags/TreeSort.lean", color: "#1a1e24" },
    { id: "AKS/Main.lean", label: "Main.lean", color: "#1a1e24" },
    { id: "AKS/Seiferas.lean", label: "Seiferas.lean", color: "#1a1e24" }
  ]
};
// ═══════════════════════════════════════════════════════

const statusColor = {
  proved: "#3fb950",
  sorry: "#d29922",
  axiom: "#f85149",
  definition: "#58a6ff",
  retired: "#30363d"  // hidden in live view, visible when scrubbing history
};

// Difficulty → radius mapping
function difficultyRadius(d, status) {
  if (status === "retired") return 0;
  if (!d) return 4;
  if (d === "days") return 6;
  if (d === "1-2 weeks" || d === "weeks") return 8;
  if (d === "2-4 weeks") return 10;
  if (d === "months") return 12;
  return 4;
}

let W = window.innerWidth;
let H = window.innerHeight;

// Compute stats
const proved = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
const sorry = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
const axiomCount = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
const defs = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
document.getElementById("stats").innerHTML =
  `<div class="num" style="color:#3fb950">${proved}</div> proved<br>` +
  `<div class="num" style="color:#d29922">${sorry}</div> sorry<br>` +
  `<div class="num" style="color:#f85149">${axiomCount}</div> axiom<br>` +
  `<div class="num" style="color:#58a6ff">${defs}</div> definitions`;

// ── Compute DAG depth (longest path from roots) ──
const nodeMap = new Map(PROOF_DATA.nodes.map(n => [n.id, n]));
const inEdges = new Map();
const outEdges = new Map();
PROOF_DATA.nodes.forEach(n => { inEdges.set(n.id, []); outEdges.set(n.id, []); });
PROOF_DATA.edges.forEach(([s, t]) => {
  if (inEdges.has(t) && outEdges.has(s)) {
    inEdges.get(t).push(s);
    outEdges.get(s).push(t);
  }
});

const depth = new Map();
function getDepth(id) {
  if (depth.has(id)) return depth.get(id);
  depth.set(id, -1);
  const parents = inEdges.get(id) || [];
  const d = parents.length === 0 ? 0 : 1 + Math.max(...parents.map(getDepth));
  depth.set(id, d);
  return d;
}
PROOF_DATA.nodes.forEach(n => getDepth(n.id));
const maxDepth = Math.max(...PROOF_DATA.nodes.map(n => depth.get(n.id)));

// ── Assign radius and initial positions ──
PROOF_DATA.nodes.forEach(n => {
  n.depth = depth.get(n.id);
  n.radius = difficultyRadius(n.difficulty, n.status);
});

// Group nodes by file for group rectangles
const fileGroups = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!fileGroups.has(n.file)) fileGroups.set(n.file, []);
  fileGroups.get(n.file).push(n);
});

// Layout: Y is INVERTED (big theorems at top, foundations at bottom)
const LAYER_H = 75;
const TOP_PAD = 60;
const GRAPH_W = 1000;
const CENTER_X = GRAPH_W / 2;

// Seed initial positions: Y by inverted depth, X spread with noise
const layers = new Map();
PROOF_DATA.nodes.forEach(n => {
  if (!layers.has(n.depth)) layers.set(n.depth, []);
  layers.get(n.depth).push(n);
});
layers.forEach((nodesInLayer, d) => {
  const count = nodesInLayer.length;
  const layerW = Math.min(GRAPH_W, count * 80);
  nodesInLayer.forEach((n, i) => {
    // Inverted: max depth at top
    n.y = TOP_PAD + (maxDepth - d) * LAYER_H;
    n.x = CENTER_X - layerW/2 + (i + 0.5) * (layerW / count);
  });
});

// ── D3 setup ──
const svg = d3.select("#graph");
const g = svg.append("g");

// Arrow markers (green for clean edges, orange for edges with sorry/axiom below)
const defs2 = svg.append("defs");
[["arrow-green", "#3fb950"], ["arrow-orange", "#d29922"]].forEach(([id, color]) => {
  defs2.append("marker")
    .attr("id", id)
    .attr("viewBox", "0 0 10 6")
    .attr("refX", 10)
    .attr("refY", 3)
    .attr("markerWidth", 8)
    .attr("markerHeight", 5)
    .attr("orient", "auto")
    .append("polygon")
    .attr("points", "0,0 10,3 0,6")
    .attr("fill", color);
});

// Zoom
const zoom = d3.zoom()
  .scaleExtent([0.15, 4])
  .on("zoom", (e) => g.attr("transform", e.transform));
svg.call(zoom);

function resetZoom(instant) {
  const graphH = TOP_PAD + (maxDepth + 1) * LAYER_H + 40;
  const scaleX = W / (GRAPH_W + 80);
  const scaleY = (H - 20) / graphH;
  let s = Math.min(scaleX, scaleY, 1.1) * 0.9;
  // On mobile the fit-all scale makes nodes sub-pixel; enforce a minimum
  // so nodes are visible and let the user pan to explore.
  if (W <= 600) s = Math.max(s, 0.7);
  const tx = (W - GRAPH_W * s) / 2;
  const ty = W <= 600 ? -graphH * s * 0.15 : 10;
  const t = d3.zoomIdentity.translate(tx, ty).scale(s);
  if (instant) {
    svg.call(zoom.transform, t);
  } else {
    svg.transition().duration(500).call(zoom.transform, t);
  }
}

let labelsVisible = true;
function toggleLabels() {
  labelsVisible = !labelsVisible;
  g.selectAll(".node-label").attr("opacity", d => (d.status !== "retired" && labelsVisible) ? 1 : 0);
}

// ── Build links ──
const links = PROOF_DATA.edges
  .filter(([s, t]) => nodeMap.has(s) && nodeMap.has(t))
  .map(([s, t]) => ({ source: nodeMap.get(s), target: nodeMap.get(t) }));

// ── Edge color computation ──
// For each node, compute whether it and all its transitive dependencies are
// "clean" (proved or definition).  Edge color = green if source is clean,
// orange if any dependency below is sorry/axiom.
const depsMap = new Map();
PROOF_DATA.nodes.forEach(n => depsMap.set(n.id, []));
links.forEach(l => {
  const arr = depsMap.get(l.target.id);
  if (arr) arr.push(l.source.id);
});

let edgeCleanMap;
function computeEdgeColors(getStatus) {
  const clean = new Map();
  function check(id) {
    if (clean.has(id)) return clean.get(id);
    clean.set(id, true); // cycle guard
    const st = getStatus(id);
    if (st !== "proved" && st !== "definition") { clean.set(id, false); return false; }
    for (const dep of (depsMap.get(id) || [])) {
      if (!check(dep)) { clean.set(id, false); return false; }
    }
    return true;
  }
  PROOF_DATA.nodes.forEach(n => check(n.id));
  edgeCleanMap = clean;
}
function edgeStroke(l) { return edgeCleanMap.get(l.source.id) ? "#3fb950" : "#d29922"; }
function edgeMarker(l) { return edgeCleanMap.get(l.source.id) ? "url(#arrow-green)" : "url(#arrow-orange)"; }

// Initial computation from live statuses
computeEdgeColors(id => nodeMap.get(id)?.status || "sorry");

// ── Force simulation for organic layout ──
// Strong Y force keeps depth ordering; charge + collision spread nodes apart
const simulation = d3.forceSimulation(PROOF_DATA.nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(50).strength(0.15))
  .force("charge", d3.forceManyBody().strength(-120))
  .force("y", d3.forceY().y(d => TOP_PAD + (maxDepth - d.depth) * LAYER_H).strength(0.85))
  .force("x", d3.forceX(CENTER_X).strength(0.03))
  .force("collision", d3.forceCollide().radius(d => d.radius + 14))
  .alphaDecay(0.025)
  .alpha(0.8);

// Save layout positions after simulation settles
let simulationDone = false;
const groupCentroids = new Map();
let currentSnapshotIndex = null; // null = live mode

simulation.on("end", () => {
  PROOF_DATA.nodes.forEach(d => { d.liveX = d.x; d.liveY = d.y; });
  fileGroups.forEach((nodes, fileId) => {
    groupCentroids.set(fileId, {
      x: nodes.reduce((s, n) => s + n.liveX, 0) / nodes.length,
      y: nodes.reduce((s, n) => s + n.liveY, 0) / nodes.length,
    });
  });
  simulationDone = true;
  // Re-fit after simulation settles (positions are now final)
  resetZoom(false);
});

function isNodeVisible(id) {
  if (currentSnapshotIndex === null || !HISTORY_DATA) {
    // Live view: hide retired nodes
    const node = nodeMap.get(id);
    return node && node.status !== "retired";
  }
  if (currentSnapshotIndex >= HISTORY_DATA.snapshots.length) {
    const node = nodeMap.get(id);
    return node && node.status !== "retired";
  }
  return !!HISTORY_DATA.snapshots[currentSnapshotIndex].nodes[id];
}

// ── Draw group rects (updated on tick) ──
const groupRects = g.append("g").selectAll("rect")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("rect")
  .attr("class", "group-rect")
  .attr("fill", d => d.color)
  .attr("stroke", "#21262d")
  .attr("stroke-width", 1);

const groupLabels = g.append("g").selectAll("text")
  .data(PROOF_DATA.groups.filter(gr => fileGroups.has(gr.id)))
  .join("text")
  .attr("class", "group-label")
  .text(d => d.label);

// ── Draw edges ──
const linkSel = g.append("g")
  .selectAll("path")
  .data(links)
  .join("path")
  .attr("class", "link")
  .attr("stroke", edgeStroke)
  .attr("stroke-width", 1.2)
  .attr("opacity", l => {
    if (l.source.status === "retired" || l.target.status === "retired") return 0;
    return 0.35;
  })
  .attr("marker-end", edgeMarker);

// ── Draw nodes ──
const nodeSel = g.append("g")
  .selectAll("circle")
  .data(PROOF_DATA.nodes)
  .join("circle")
  .attr("class", "node-circle")
  .attr("r", d => d.radius)
  .attr("fill", d => statusColor[d.status])
  .attr("stroke", d => d3.color(statusColor[d.status]).darker(0.5).formatHex())
  .attr("opacity", d => d.status === "retired" ? 0 : 1)
  .call(d3.drag()
    .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.15).restart(); d.fx = d.x; d.fy = d.y; })
    .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
    .on("end", (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
  );

// ── Node labels ──
const labelSel = g.append("g")
  .selectAll("text")
  .data(PROOF_DATA.nodes)
  .join("text")
  .attr("class", "node-label")
  .attr("opacity", d => d.status === "retired" ? 0 : 1)
  .text(d => {
    let name = d.id;
    name = name.replace("RegularGraph.", "").replace("CLM", "");
    if (name.length > 22) name = name.substring(0, 20) + "..";
    return name;
  });

// ── Edge path helper ──
function edgePath(d) {
  const sx = d.source.x, sy = d.source.y;
  const tx = d.target.x, ty = d.target.y;
  const dx = tx - sx, dy = ty - sy;
  const len = Math.sqrt(dx*dx + dy*dy) || 1;
  // Shorten at both ends by node radii
  const sr = d.source.radius + 2;
  const tr = d.target.radius + 5; // extra for arrowhead
  const bx = sx + (dx/len)*sr, by = sy + (dy/len)*sr;
  const ex = tx - (dx/len)*tr, ey = ty - (dy/len)*tr;
  // Gentle curve
  const mx = (bx + ex) / 2, my = (by + ey) / 2;
  const offset = (ex - bx) * 0.12;
  return `M${bx},${by} Q${mx + offset},${my} ${ex},${ey}`;
}

// ── Tick ──
simulation.on("tick", () => {
  linkSel.attr("d", edgePath);

  nodeSel.attr("cx", d => d.x).attr("cy", d => d.y);

  labelSel
    .attr("x", d => d.x)
    .attr("y", d => d.y + d.radius + 12);

  // Update group rectangles
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    const xs = nodes.map(n => n.x), ys = nodes.map(n => n.y);
    d3.select(this)
      .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
      .attr("width", Math.max(...xs) - Math.min(...xs) + 2*pad)
      .attr("height", Math.max(...ys) - Math.min(...ys) + 2*pad);
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes || !nodes.length) return;
    const pad = 24;
    d3.select(this)
      .attr("x", Math.min(...nodes.map(n => n.x)) - pad + 6)
      .attr("y", Math.min(...nodes.map(n => n.y)) - pad + 13);
  });
});

// ── Tooltip ──
const tooltip = document.getElementById("tooltip");

nodeSel.on("mouseover", (e, d) => {
  tooltip.style.display = "block";
  let html = `<div class="tt-name">${d.id}</div>`;
  html += `<div class="tt-file">${d.file}:${d.line} &mdash; <span style="color:${statusColor[d.status]}">${d.status}</span></div>`;
  html += `<div class="tt-sig">${escHtml(d.sig)}</div>`;
  html += `<div class="tt-desc">${d.desc}</div>`;
  if (d.difficulty) html += `<div class="tt-diff">Estimated difficulty: ${d.difficulty}</div>`;
  tooltip.innerHTML = html;
})
.on("mousemove", (e) => {
  let x = e.clientX + 16, y = e.clientY + 16;
  if (x + 480 > W) x = e.clientX - 496;
  if (y + 200 > H) y = e.clientY - 200;
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
})
.on("mouseout", () => { tooltip.style.display = "none"; })
.on("click", (e, d) => {
  window.open(`${PROOF_DATA.repo}/blob/main/${d.file}#L${d.line}`, "_blank");
});

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Highlight connected nodes on hover ──
nodeSel.on("mouseover.highlight", (e, d) => {
  const connected = new Set([d.id]);
  links.forEach(l => {
    if (l.source.id === d.id) connected.add(l.target.id);
    if (l.target.id === d.id) connected.add(l.source.id);
  });
  nodeSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return connected.has(n.id) ? 1 : 0.15;
  });
  labelSel.attr("opacity", n => {
    if (!isNodeVisible(n.id)) return 0;
    return (connected.has(n.id) && labelsVisible) ? 1 : 0.05;
  });
  linkSel.attr("opacity", l => {
    if (!isNodeVisible(l.source.id) || !isNodeVisible(l.target.id)) return 0;
    return (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.04;
  });
}).on("mouseout.highlight", () => {
  // Restore timeline state
  const slider = document.getElementById('timeSlider');
  if (HISTORY_DATA && slider && parseInt(slider.value) < HISTORY_DATA.snapshots.length) {
    applySnapshot(parseInt(slider.value), false);
  } else {
    nodeSel.attr("opacity", d => d.status === "retired" ? 0 : 1);
    labelSel.attr("opacity", d => (d.status !== "retired" && labelsVisible) ? 1 : 0);
    linkSel.attr("opacity", l => {
      if (l.source.status === "retired" || l.target.status === "retired") return 0;
      return 0.35;
    }).attr("stroke", edgeStroke).attr("marker-end", edgeMarker);
  }
});

// ── Initial zoom to fit (instant, no transition) ──
setTimeout(() => resetZoom(true), 100);

// ═══════════════════════════════════════════════════════
// TIMELINE ANIMATION — loads history.json, scrubs through proof history
// ═══════════════════════════════════════════════════════
let HISTORY_DATA = null;
let playing = false;
let playInterval = null;
let playSpeed = 200;

fetch('history.json')
  .then(r => { if (!r.ok) throw new Error('No history'); return r.json(); })
  .then(data => { HISTORY_DATA = data; initTimeline(); })
  .catch(() => { /* No history.json — static mode only */ });

function initTimeline() {
  if (!HISTORY_DATA || !HISTORY_DATA.snapshots.length) return;
  const slider = document.getElementById('timeSlider');
  slider.max = HISTORY_DATA.snapshots.length; // 0..N-1 = snapshots, N = live
  slider.value = slider.max;
  document.getElementById('timeline').style.display = 'flex';
  updateDateDisplay(parseInt(slider.max));
}

function applySnapshot(index, animated) {
  const dur = animated ? 120 : 0;
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const snapshot = isLive ? null : HISTORY_DATA.snapshots[index];
  currentSnapshotIndex = isLive ? null : index;

  // Build visibility map
  const vis = new Map();
  PROOF_DATA.nodes.forEach(d => {
    vis.set(d.id, isLive || !!snapshot.nodes[d.id]);
  });

  // Move node positions: visible → layout position, hidden → group centroid
  if (simulationDone) {
    PROOF_DATA.nodes.forEach(d => {
      if (vis.get(d.id)) {
        d.x = d.liveX;
        d.y = d.liveY;
      } else {
        const c = groupCentroids.get(d.file);
        if (c) { d.x = c.x; d.y = c.y; }
      }
    });
  }

  // Helper: optionally wrap selection in a transition.
  // When instant (dur=0), interrupt any in-progress transitions to prevent flickering.
  function tw(sel) {
    if (dur > 0) return sel.transition().duration(dur);
    sel.interrupt();
    return sel;
  }

  // Nodes: position, color, size, opacity
  tw(nodeSel)
    .attr("cx", d => d.x).attr("cy", d => d.y)
    .attr("r", d => vis.get(d.id) ? (d.radius || 4) : 0)
    .attr("fill", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return statusColor[st] || statusColor[d.status];
    })
    .attr("stroke", d => {
      const st = isLive ? d.status : (snapshot.nodes[d.id] || null);
      return d3.color(statusColor[st] || statusColor[d.status]).darker(0.5).formatHex();
    })
    .attr("opacity", d => vis.get(d.id) ? 1 : 0);

  // Labels: position and opacity
  tw(labelSel)
    .attr("x", d => d.x).attr("y", d => d.y + d.radius + 12)
    .attr("opacity", d => (vis.get(d.id) && labelsVisible) ? 1 : 0);

  // Recompute edge colors for this snapshot's statuses
  computeEdgeColors(id => {
    const st = isLive ? nodeMap.get(id)?.status : (snapshot.nodes[id] || null);
    return st || nodeMap.get(id)?.status || "sorry";
  });

  // Edges: path, color, opacity
  tw(linkSel)
    .attr("d", edgePath)
    .attr("stroke", edgeStroke)
    .attr("marker-end", edgeMarker)
    .attr("opacity", l => {
      return (isLive || (vis.get(l.source.id) && vis.get(l.target.id))) ? 0.35 : 0;
    });

  // Group rects: recompute bounds from visible nodes only
  groupRects.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      const xs = vn.map(n => n.x), ys = vn.map(n => n.y);
      el.attr("opacity", 1)
        .attr("x", Math.min(...xs) - pad).attr("y", Math.min(...ys) - pad)
        .attr("width", Math.max(...xs) - Math.min(...xs) + 2 * pad)
        .attr("height", Math.max(...ys) - Math.min(...ys) + 2 * pad);
    }
  });
  groupLabels.each(function(gr) {
    const nodes = fileGroups.get(gr.id);
    if (!nodes) return;
    const vn = nodes.filter(n => vis.get(n.id));
    const el = tw(d3.select(this));
    if (vn.length === 0) {
      el.attr("opacity", 0);
    } else {
      const pad = 24;
      el.attr("opacity", 1)
        .attr("x", Math.min(...vn.map(n => n.x)) - pad + 6)
        .attr("y", Math.min(...vn.map(n => n.y)) - pad + 13);
    }
  });

  // Stats and date display
  updateTimelineStats(isLive, snapshot);
  updateDateDisplay(index);
}

function updateTimelineStats(isLive, snapshot) {
  let p, s, a, df;
  if (isLive) {
    p = PROOF_DATA.nodes.filter(n => n.status === "proved").length;
    s = PROOF_DATA.nodes.filter(n => n.status === "sorry").length;
    a = PROOF_DATA.nodes.filter(n => n.status === "axiom").length;
    df = PROOF_DATA.nodes.filter(n => n.status === "definition").length;
  } else {
    const vals = Object.values(snapshot.nodes);
    p = vals.filter(v => v === "proved").length;
    s = vals.filter(v => v === "sorry").length;
    a = vals.filter(v => v === "axiom").length;
    df = vals.filter(v => v === "definition").length;
  }
  document.getElementById("stats").innerHTML =
    `<div class="num" style="color:#3fb950">${p}</div> proved<br>` +
    `<div class="num" style="color:#d29922">${s}</div> sorry<br>` +
    `<div class="num" style="color:#f85149">${a}</div> axiom<br>` +
    `<div class="num" style="color:#58a6ff">${df}</div> definitions`;
}

function updateDateDisplay(index) {
  const max = HISTORY_DATA.snapshots.length;
  const isLive = index >= max;
  const dateEl = document.getElementById('timeDate');
  const liveEl = document.getElementById('liveBadge');
  if (isLive) {
    dateEl.textContent = 'Current';
    liveEl.style.visibility = 'visible';
  } else {
    const s = HISTORY_DATA.snapshots[index];
    const d = new Date(s.date);
    const ds = d.toLocaleDateString('en-GB', {year:'numeric', month:'short', day:'numeric'});
    const msg = s.message.length > 50 ? s.message.substring(0, 47) + '...' : s.message;
    dateEl.textContent = `${ds} \u2014 ${msg}`;
    liveEl.style.visibility = 'hidden';
  }
}

function scrubTo(value) {
  applySnapshot(parseInt(value), false);
}

function advanceFrame() {
  const slider = document.getElementById('timeSlider');
  const next = parseInt(slider.value) + 1;
  if (next > parseInt(slider.max)) {
    togglePlay();
    return;
  }
  slider.value = next;
  applySnapshot(next, true);
}

function startPlaying() {
  clearInterval(playInterval);
  playInterval = setInterval(advanceFrame, playSpeed);
}

function togglePlay() {
  playing = !playing;
  document.getElementById('playBtn').innerHTML = playing ? '&#9646;&#9646;' : '&#9654;';
  if (playing) {
    const slider = document.getElementById('timeSlider');
    if (parseInt(slider.value) >= parseInt(slider.max)) {
      slider.value = 0;
      applySnapshot(0, false);
    }
    startPlaying();
  } else {
    clearInterval(playInterval);
  }
}

function updateSpeed() {
  playSpeed = parseInt(document.getElementById('speedSelect').value);
  if (playing) startPlaying();
}

// ═══════════════════════════════════════════════════════
// MOBILE / RESPONSIVE SUPPORT
// ═══════════════════════════════════════════════════════

// Resize handler — recompute dimensions and re-fit
window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  resetZoom();
});

// Legend toggle for mobile
function toggleLegend() {
  document.getElementById('legend').classList.toggle('open');
}

// Close legend when tapping elsewhere on mobile
document.addEventListener('click', (e) => {
  const legend = document.getElementById('legend');
  const toggle = document.getElementById('legend-toggle');
  if (!legend.contains(e.target) && e.target !== toggle) {
    legend.classList.remove('open');
  }
});

// Touch support for tooltips (tap node = show tooltip, tap elsewhere = dismiss)
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let activeTooltipNode = null;

if (isTouchDevice) {
  // Prevent default touch-drag on nodes so tooltip shows on tap
  nodeSel.on('touchstart', function(e, d) {
    // Single-finger tap: show tooltip
    if (e.touches.length === 1) {
      e.preventDefault();
      e.stopPropagation();

      if (activeTooltipNode === d) {
        // Second tap on same node: open link
        window.open(`${PROOF_DATA.repo}/blob/main/${d.file}#L${d.line}`, '_blank');
        dismissTooltip();
        return;
      }

      activeTooltipNode = d;

      // Show tooltip content
      let html = `<div class="tt-name">${d.id}</div>`;
      html += `<div class="tt-file">${d.file}:${d.line} &mdash; <span style="color:${statusColor[d.status]}">${d.status}</span></div>`;
      html += `<div class="tt-sig">${escHtml(d.sig)}</div>`;
      html += `<div class="tt-desc">${d.desc}</div>`;
      if (d.difficulty) html += `<div class="tt-diff">Estimated difficulty: ${d.difficulty}</div>`;
      html += `<div style="margin-top:8px;font-size:10px;color:#484f58;">Tap again to open on GitHub</div>`;
      tooltip.innerHTML = html;
      tooltip.style.display = 'block';

      // Position: on mobile, anchor to bottom of viewport; on desktop, near touch point
      if (W <= 600) {
        tooltip.style.left = '16px';
        tooltip.style.top = '';
        tooltip.style.bottom = '8px';
      } else {
        const touch = e.touches[0];
        let x = touch.clientX + 16, y = touch.clientY + 16;
        if (x + 480 > W) x = touch.clientX - 496;
        if (y + 200 > H) y = touch.clientY - 200;
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
        tooltip.style.bottom = '';
      }

      // Highlight connected
      const connected = new Set([d.id]);
      links.forEach(l => {
        if (l.source.id === d.id) connected.add(l.target.id);
        if (l.target.id === d.id) connected.add(l.source.id);
      });
      nodeSel.attr('opacity', n => {
        if (!isNodeVisible(n.id)) return 0;
        return connected.has(n.id) ? 1 : 0.15;
      });
      labelSel.attr('opacity', n => {
        if (!isNodeVisible(n.id)) return 0;
        return (connected.has(n.id) && labelsVisible) ? 1 : 0.05;
      });
      linkSel.attr('opacity', l => {
        if (!isNodeVisible(l.source.id) || !isNodeVisible(l.target.id)) return 0;
        return (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.04;
      });
    }
  });

  // Tap on background dismisses tooltip
  svg.on('touchstart.dismiss', (e) => {
    if (e.target.tagName === 'svg' || e.target.classList.contains('group-rect')) {
      dismissTooltip();
    }
  });

  // Also dismiss on tap outside the tooltip itself
  document.addEventListener('touchstart', (e) => {
    if (activeTooltipNode && !tooltip.contains(e.target) &&
        !e.target.classList.contains('node-circle')) {
      dismissTooltip();
    }
  });
}

function dismissTooltip() {
  activeTooltipNode = null;
  tooltip.style.display = 'none';
  tooltip.style.bottom = '';
  // Restore normal opacity
  const slider = document.getElementById('timeSlider');
  if (HISTORY_DATA && slider && parseInt(slider.value) < HISTORY_DATA.snapshots.length) {
    applySnapshot(parseInt(slider.value), false);
  } else {
    nodeSel.attr('opacity', d => isNodeVisible(d.id) ? 1 : 0);
    labelSel.attr('opacity', d => (isNodeVisible(d.id) && labelsVisible) ? 1 : 0);
    linkSel.attr('opacity', 0.35).attr('stroke', edgeStroke).attr('marker-end', edgeMarker);
  }
}

// Mark body when timeline is active (for CSS adjustments)
const timelineObserver = new MutationObserver(() => {
  const tl = document.getElementById('timeline');
  document.body.classList.toggle('has-timeline', tl.style.display === 'flex');
});
timelineObserver.observe(document.getElementById('timeline'), { attributes: true, attributeFilter: ['style'] });
</script>
</body>
</html>
